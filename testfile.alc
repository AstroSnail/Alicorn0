let prim-string-wrap = intrinsic "return terms.value.prim_string_type" : wrapped(prim-type)
let prim-string = unwrap(prim-type, prim-string-wrap)

let new-prim-type-inner =
	intrinsic
		""""
			local function new_prim_type(name)
				local unique_id = { name = name }
				local value_array = terms_gen.declare_array(terms.value)
				local basetype = terms.value.prim_user_defined_type(unique_id, value_array())
				return basetype
			end
			return new_prim_type
		:
		prim-func-type (name : prim-string) -> (t : wrapped(prim-type))
let new-prim-type =
	lambda ((name : prim-string))
		let (t) = new-prim-type-inner(name)
		unwrap(prim-type, t)
let syntax = new-prim-type("syntax")
let literal = new-prim-type("literal")

let new-prim-type-family-inner =
	intrinsic
		""""
			local function new_prim_type_family(name, nparams, sig)
				local unique_id = { name = name }
				local typed_array = terms_gen.declare_array(terms.typed_term)
				local params = typed_array()
				for i = 1, nparams do
					params:append(terms.typed_term.bound_variable(i + 1))
				end
				local body = terms.typed_term.tuple_elim(
					terms.typed_term.bound_variable(1),
					nparams,
					terms.typed_term.prim_user_defined_type(
						unique_id,
						params
					)
				)
				return terms.value.closure(body, terms.runtime_context())
			end
			return new_prim_type_family
		:
		prim-func-type
			name : prim-string
			nparams : prim-number
			signature : wrapped(type_(1))
			->
			family : wrapped(unwrap(type_(1), signature))
let new-prim-type-family =
	lambda 
		(name : prim-string) (nparams : prim-number) (signature : type_(1)) #TODO make nparams not exist by deriving it from the signature
		let (family) = new-prim-type-family-inner(name, nparams, wrap(type_(1), signature))
		unwrap(signature, family)
let matcher =
	new-prim-type-family
		"matcher"
		2
		forall (ud : prim-type) (res : prim-type) -> res : prim-type
let reducer =
	new-prim-type-family
		"reducer"
		3
		forall (store : prim-type) (res : prim-type) (err : prim-type) -> res : prim-type




let prim-matcher =
	lambda ((ud-wrap : wrapped(prim-type)) (res-wrap : wrapped(prim-type)))
		let ud = unwrap(prim-type, ud-wrap)
		let res = unwrap(prim-type, res-wrap)
		matcher(ud, res)

let prim-nil-handler =
	lambda ((ud-wrap : wrapped(prim-type)) (res-wrap : wrapped(prim-type)))
		let ud = unwrap(prim-type, ud-wrap)
		let res = unwrap(prim-type, res-wrap)
		prim-func-type (userdata : ud) -> (r : res)
let prim-matcher-is-nil =
	intrinsic
		""""
			local function is_nil(_ud, _res, accept_handler)
				return metalang.isnil(accept_handler)
			end
			return is_nil
		:
		prim-func-type
			ud : wrapped(prim-type)
			res : wrapped(prim-type)
			accept-handler : prim-nil-handler(ud, res)
			->
			m : prim-matcher(ud, res)

let prim-pair-handler =
	lambda ((ud-wrap : wrapped(prim-type)) (res-wrap : wrapped(prim-type)))
		let ud = unwrap(prim-type, ud-wrap)
		let res = unwrap(prim-type, res-wrap)
		prim-func-type (userdata : ud) (a : syntax) (b : syntax) -> (r : res)
let prim-matcher-is-pair =
	intrinsic
		""""
			local function is_pair(_ud, _res, accept_handler)
				return metalang.ispair(accept_handler)
			end
			return is_pair
		:
		prim-func-type
			ud : wrapped(prim-type)
			res : wrapped(prim-type)
			accept-handler : prim-pair-handler(ud, res)
			->
			m : prim-matcher(ud, res)

let prim-symbol-handler =
	lambda ((ud-wrap : wrapped(prim-type)) (res-wrap : wrapped(prim-type)))
		let ud = unwrap(prim-type, ud-wrap)
		let res = unwrap(prim-type, res-wrap)
		prim-func-type (userdata : ud) (symbol : prim-string) -> (r : res)
let prim-matcher-is-symbol =
	intrinsic
		""""
			local function is_symbol(_ud, _res, accept_handler)
				return metalang.issymbol(accept_handler)
			end
			return is_symbol
		:
		prim-func-type
			ud : wrapped(prim-type)
			res : wrapped(prim-type)
			accept-handler : prim-symbol-handler(ud, res)
			->
			m : prim-matcher(ud, res)

let prim-value-handler =
	lambda ((ud-wrap : wrapped(prim-type)) (res-wrap : wrapped(prim-type)))
		let ud = unwrap(prim-type, ud-wrap)
		let res = unwrap(prim-type, res-wrap)
		prim-func-type (userdata : ud) (val : literal) -> (r : res)
let prim-matcher-is-value =
	intrinsic
		""""
			local function is_value(_ud, _res, accept_handler)
				return metalang.isvalue(accept_handler)
			end
			return is_value
		:
		prim-func-type
			ud : wrapped(prim-type)
			res : wrapped(prim-type)
			accept-handler : prim-value-handler(ud, res)
			->
			m : prim-matcher(ud, res)

#let prim-reducer =
	lambda ((store-wrap : wrapped(prim-type)) (res-wrap : wrapped(prim-type)) (err-wrap : wrapped(prim-type)))
		let store = unwrap(prim-type, store-wrap)
		let res = unwrap(prim-type, res-wrap)
		let err = unwrap(prim-type, err-wrap)
		reducer(store, res, err)

#let prim-reducible-handler =
	lambda ((ud-wrap : wrapped(prim-type)) (prod-wrap : wrapped(prim-type)) (res-wrap : wrapped(prim-type)))
		let ud = unwrap(prim-type, ud-wrap)
		let prod = unwrap(prim-type, prod-wrap)
		let res = unwrap(prim-type, res-wrap)
		prim-func-type (userdata : ud) (product : prod) -> (r : res)
#let prim-matcher-reducible =
	intrinsic
		""""
			local function reducible(_store, _prod, _err, _ud, _res, red, storage, accept_handler)
				return red(accept_handler, table.unpack(storage))
			end
			return reducible
		:
		prim-func-type
			store : wrapped(prim-type)
			prod : wrapped(prim-type)
			err : wrapped(prim-type)
			ud : wrapped(prim-type)
			res : wrapped(prim-type)
			red : prim-reducer(store, prod, err)
			storage : unwrap(prim-type, store)
			accept-handler : prim-reducible-handler(ud, prod, res)
			->
			m : prim-matcher(ud, res)
