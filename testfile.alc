let prim-arith-binop = (prim-func-type (a : prim-number) (b : prim-number) -> (c : prim-number))
let prim-sub = (intrinsic "return function(a, b) return a - b end" : prim-arith-binop)

#let prim-sub = (intrinsic "return function(a, b) return a - b end" : (prim-func-type (a : prim-number) (b : prim-number) -> (c : prim-number)))

#let foo = (record (bar = 5) (baz = 6))
#let subbed = prim-sub foo.bar y

# FIXME: type of universe
# we need to wrap this, and wrap takes a type in star-10
# so we have to settle for star-9
let universe = type_(9)

let prim-bool-wrap            = intrinsic "return terms.value.prim_bool_type"      : wrapped(prim-type)
let prim-string-wrap          = intrinsic "return terms.value.prim_string_type"    : wrapped(prim-type)
let prim-syntax-wrap          = intrinsic "return terms.prim_syntax_type"          : wrapped(prim-type)
let prim-environment-wrap     = intrinsic "return terms.prim_environment_type"     : wrapped(prim-type)
let prim-goal-wrap            = intrinsic "return terms.prim_goal_type"            : wrapped(prim-type)
let prim-inferrable-term-wrap = intrinsic "return terms.prim_inferrable_term_type" : wrapped(prim-type)
let prim-checkable-term-wrap  = intrinsic "return terms.prim_checkable_term_type"  : wrapped(prim-type)
let prim-lua-error-wrap       = intrinsic "return terms.prim_lua_error_type"       : wrapped(prim-type)

let prim-bool            = unwrap(prim-type, prim-bool-wrap)
let prim-string          = unwrap(prim-type, prim-string-wrap)
let prim-syntax          = unwrap(prim-type, prim-syntax-wrap)
let prim-environment     = unwrap(prim-type, prim-environment-wrap)
let prim-goal            = unwrap(prim-type, prim-goal-wrap)
let prim-inferrable-term = unwrap(prim-type, prim-inferrable-term-wrap)
let prim-checkable-term  = unwrap(prim-type, prim-checkable-term-wrap)
let prim-lua-error       = unwrap(prim-type, prim-lua-error-wrap)

let prim-string-concat = intrinsic "return function(a, b) return a .. b end" :
	prim-func-type (a : prim-string) (b : prim-string) -> (c : prim-string)

# lmao bootstrapping problem
let prim-unique-id-wrap = intrinsic
	"return terms.value.prim_user_defined_type({ name = \"unique_id\" }, terms_gen.declare_array(terms.value)())"
	:
	wrapped(prim-type)
let prim-unique-id = unwrap(prim-type, prim-unique-id-wrap)
let new-prim-unique-id = lambda ((name : prim-string))
	let source0 = "return { name = \""
	let (source1) = prim-string-concat(source0, name)
	let (source2) = prim-string-concat(source1, "\" }")
	intrinsic source2 : prim-unique-id

let new-prim-type-family-inner = intrinsic
	""""
		local typed_array = terms_gen.declare_array(terms.typed_term)
		local string_array = terms_gen.declare_array(terms_gen.builtin_string)
		local function length(defn, len)
			len = len or 0
			local constructor, arg = defn:unwrap_enum_value()
			if constructor == "empty" then
				return len
			elseif constructor == "cons" then
				local elements = arg:unwrap_tuple_value()
				local next_defn = elements[1]
				return length(next_defn, len + 1)
			else
				error("unknown tuple defn constructor")
			end
		end
		local function new_prim_type_family(unique_id, sig)
			local param_type, _, _, _ = sig:unwrap_pi()
			local param_decls = param_type:unwrap_tuple_type()
			local nparams = length(param_decls)
			local params = typed_array()
			local param_names = string_array()
			for i = 1, nparams do
				params:append(terms.typed_term.bound_variable(i + 1))
				param_names:append("#type-family-A-" .. tostring(i))
			end
			local body = terms.typed_term.tuple_elim(
				param_names,
				terms.typed_term.bound_variable(1),
				nparams,
				terms.typed_term.prim_user_defined_type_cons(
					unique_id,
					params
				)
			)
			return terms.value.closure("#type-family-B", body, terms.runtime_context())
		end
		return new_prim_type_family
	:
	prim-func-type
		unique-id : prim-unique-id
		signature : wrapped(type_(1))
		->
		family    : wrapped(unwrap(type_(1), signature))
let new-prim-type-family = lambda (unique-id : prim-unique-id, signature : type_(1))
	let (family) = new-prim-type-family-inner(unique-id, wrap(type_(1), signature))
	unwrap(signature, family)
let new-prim-type = lambda ((unique-id : prim-unique-id))
	let Tfam = new-prim-type-family unique-id
		forall -> T : prim-type
	Tfam()

let prim-array-type = new-prim-type-family new-prim-unique-id("array")
	forall (T : prim-type) -> T : prim-type

let prim-array-new = lambda ((T : prim-type))
	let inner = intrinsic
		""""
			local function array_new()
				return {}
			end
			return array_new
		:
		prim-func-type -> (arr : prim-array-type(T))
	let (arr) = inner()
	arr
let prim-array-set = lambda (T : prim-type, arr : prim-array-type(T), index : prim-number, elem : T)
	let inner = intrinsic
		""""
			local function array_set(array, index, elem)
				-- we have to clone because can't guarantee input array isn't reused
				-- Yet. growth mindset.
				cloned = {}
				for i, v in ipairs(array) do
					cloned[i] = v
				end
				cloned[index] = elem
				return cloned
			end
			return array_set
		:
		prim-func-type
			arr   : prim-array-type(T)
			index : prim-number
			elem  : T
			->
			arr   : prim-array-type(T)
	let (arr) = inner(arr, index, elem)
	arr
let prim-array-get = lambda (T : prim-type, arr : prim-array-type(T), index : prim-number)
	let inner = intrinsic
		""""
			local function array_get(array, index)
				return array[index]
			end
			return array_get
		:
		prim-func-type
			arr   : prim-array-type(T)
			index : prim-number
			->
			elem  : T
	let (elem) = inner(arr, index)
	(the T elem)

let prim-file-read =
	intrinsic
		""""
			local fs = require 'fs'
			return fs.readFileSync
		:
		prim-func-type (fname : prim-string) -> (content : prim-string)

let void =
	unwrap
		type
		intrinsic
			""""
				local val_array = terms_gen.declare_array(terms.value)
				local decl = terms.value.enum_value("empty", terms.value.tuple_value(val_array()))
				local basetype = terms.value.enum_type(decl)
				return basetype
			:
			wrapped type

let prim-unit = new-prim-type(new-prim-unique-id("prim-unit"))
let prim-nil = intrinsic "return nil" : prim-unit

let only-accept-prim-tuples-inner-prim =
	intrinsic
		""""
			local function check_prim_tuple(subject, consequent, alternate)
				if subject:is_prim_tuple_type() then
					return consequent
				else
					return alternate
				end
			end
			return check_prim_tuple
		:
		prim-func-type
			subject : wrapped(type)
			consequent : wrapped(prim-type)
			alternate : wrapped(prim-type)
			->
			result : wrapped(prim-type)

let only-accept-prim-tuples-inner =
	lambda (subject : wrapped(type), consequent : prim-type, alternate : prim-type)
		let (res) =
			only-accept-prim-tuples-inner-prim
				subject
				wrap prim-type consequent
				wrap prim-type alternate
		unwrap prim-type res
let only-accept-prim-tuples =
	lambda ((subject : wrapped(type)))
		only-accept-prim-tuples-inner
			subject
			prim-unit
			wrapped void

let prim-tuple-type-to-tuple-type-inner =
	intrinsic
		""""
			local function prim_tuple_to_tuple(prim_tuple_type)
				local decls = prim_tuple_type:unwrap_prim_tuple_type()
				-- this conversion happens to work since the eliminator for prim tuples and tuples is the same term
				local newbasetype = terms.value.tuple_type(decls)
				return newbasetype
			end
			return prim_tuple_to_tuple
		:
		prim-func-type
			t : wrapped(type)
			valid : only-accept-prim-tuples(t)
			->
			res : wrapped(type)

let prim-tuple-type-to-tuple-type =
	lambda (t : wrapped(type), valid : only-accept-prim-tuples(t))
		let (res) = prim-tuple-type-to-tuple-type-inner(t, valid)
		res

let prim-tuple-to-tuple-inner =
	intrinsic
		""""
			return function(_type, _valid, val)
				local elems = val:unwrap_prim_tuple_value()
				local vals = terms_gen.delcare_array(terms.value)()
				for _, v in ipairs(elems) do
					vals:append(terms.value.prim(v))
				end
				return terms.value.tuple_value(vals)
			end
		:
		prim-func-type
			t : wrapped(type)
			valid : only-accept-prim-tuples(t)
			val : wrapped(unwrap(type, t))
			->
			res : wrapped(unwrap(type, prim-tuple-type-to-tuple-type(t, valid)))

let prim-tuple-to-tuple =
	lambda (t : wrapped(type), valid : only-accept-prim-tuples(t), val : unwrap(type, t))
		let (res) = prim-tuple-to-tuple-inner(t, valid, wrap(unwrap(type, t), val))
		unwrap(unwrap(type, prim-tuple-type-to-tuple-type(t, valid)), res)

let tuple-to-prim-tuple-inner =
	intrinsic
		""""
			return function(_type, _valid, val)
				local elems = val:unwrap_tuple_value()
				local leading = terms_gen.declare_array(terms_gen.any_lua_type)()
				local stuck = false
				local stuck_elem = nil
				local trailing = terms_gen.declare_ array(terms.value)()
				for _, v in ipairs(elems) do
					if stuck then
						trailing:append(v)
					elseif v:is_prim() then
						leading:append(v:unwrap_prim())
					elseif v:is_neutral() then
						stuck, stuck_elem = true, v:unwrap_neutral()
					else
						error "found an element in a tuple being converted to prim-tuple that was neither prim nor neutral"
					end
				end
				if not stuck then
					return terms.value.prim_tuple_value(leading)
				else
					return terms.value.neutral(terms.neutral_value.prim_tuple_stuck(leading, stuck_elem, trailing))
				end
			end
		:
		prim-func-type
			t : wrapped(type)
			valid : only-accept-prim-tuples(t)
			val : wrapped(unwrap(type, prim-tuple-type-to-tuple-type(t, valid)))
			->
			res : wrapped(unwrap(type, t))

let tuple-to-prim-tuple =
	lambda (t : wrapped(type), valid : only-accept-prim-tuples(t), val : unwrap(type, prim-tuple-type-to-tuple-type(t, valid)))
		let (res) =
			tuple-to-prim-tuple-inner(t, valid, wrap(unwrap(type, prim-tuple-type-to-tuple-type(t, valid)), val))
		unwrap(unwrap(type, t), res)

let only-accept-prim-funcs-inner-prim =
	intrinsic
		""""
			local function check_prim_func(subject, consequent, alternate)
				if subject:is_prim_function_type() then
					return consequent
				else
					return alternate
				end
			end
			return check_prim_func
		:
		prim-func-type
			subject : wrapped(type)
			consequent : wrapped(prim-type)
			alternate : wrapped(prim-type)
			->
			result : wrapped(prim-type)

let only-accept-prim-funcs-inner =
	lambda (subject : wrapped(type), consequent : prim-type, alternate : prim-type)
		let (res) =
			only-accept-prim-funcs-inner-prim
				subject
				wrap prim-type consequent
				wrap prim-type alternate
		unwrap prim-type res
let only-accept-prim-funcs =
	lambda ((subject : wrapped(type)))
		only-accept-prim-funcs-inner
			subject
			prim-unit
			wrapped void

let get-prim-func-arg-inner =
	intrinsic
		""""
			local function get_prim_func_arg(subject, valid)
				local param_type, result_type = subject:unwrap_prim_function_type()
				return param_type, nil
			end
			return get_prim_func_arg
		:
		prim-func-type
			subject : wrapped(type)
			valid :
				only-accept-prim-funcs
					subject
			->
			result : wrapped(type)
			valid :
				only-accept-prim-tuples
					result

let just-args =
	lambda (subject : wrapped(type), valid : only-accept-prim-funcs(subject))
		let (result, valid) = get-prim-func-arg-inner(subject, valid)
		result

let func-conv-res-type = 
	lambda ((argtype : wrapped(type)))
		forall arg : unwrap(type, argtype)
			->
			res : wrapped(type)
			valid :
				only-accept-prim-tuples
					res

let get-prim-func-res-inner =
	intrinsic
		""""
			local function get_prim_func_res(subject, valid)
				local param_type, result_type = subject:unwrap_prim_function_type()
				local typed_array = terms_gen.declare_array(terms.typed_term)
				local tuple_build = terms.typed_term.tuple_cons(
					typed_array(
						terms.typed_term.prim_wrap(
							terms.typed_term.application(
								terms.typed_term.bound_variable(1),
								terms.typed_term.bound_variable(2)
							)
						),
						terms.typed_term.literal(terms.value.prim(nil))
					)
				)
				local ctx = terms.runtime_context():append(result_type)
				return terms.value.closure("#TEST-1", tuple_build, ctx)
			end
			return get_prim_func_res
		:
		prim-func-type
			subject : wrapped(type)
			valid :
				only-accept-prim-funcs
					subject
			->
			results :
				wrapped
					func-conv-res-type
						just-args(subject, valid)
						

let foo =
	prim-func-type (x : prim-number) (y : prim-number) -> (res : prim-number)

foo

let (oldargs oldargs-valid) = get-prim-func-arg-inner(wrap(type, foo), prim-nil)
let (newargs) = prim-tuple-type-to-tuple-type-inner(oldargs, oldargs-valid)
newargs

let id_type = forall name : prim-number -> name : prim-number

let id_num = lambda (T : prim-number)
	T

(the id_type id_num)

let sub = lambda (x : prim-number, y : prim-number)
	let (res) = prim-sub(x, y)
	res

let sub_type = forall (x : prim-number) (y : prim-number) -> res : prim-number

(the sub_type sub)

# FIXME: adding comments immediately before let ptuple = tuple-to-prim-tuple(oldargs, oldargs-valid, args)
# is breaking the lambda operative

let (orig-results) = get-prim-func-res-inner(wrap(type, foo), prim-nil)
let orig-results = unwrap(func-conv-res-type(oldargs), orig-results)
let new-results =
	lambda ((args : unwrap(type, newargs)))
		let ptuple = tuple-to-prim-tuple(oldargs, oldargs-valid, args)
		let orig-results-res = apply(orig-results, ptuple)
		let (newres valid) = orig-results-res
		newres

let prim-func-type-to-func-type =
	lambda (T : type, valid : only-accept-prim-funcs(wrap(type, T)))
		let (oldargs oldargs-valid) = get-prim-func-arg-inner(wrap(type, T), valid)
		let (newargs) = prim-tuple-type-to-tuple-type-inner(oldargs, oldargs-valid)
		let (orig-results-wrapped) = get-prim-func-res-inner(wrap(type, T), valid)
		let orig-results = unwrap(func-conv-res-type(oldargs), orig-results-wrapped)
		
		let new-results =
			lambda ((args : unwrap(type, newargs)))
				let ptuple = tuple-to-prim-tuple(oldargs, oldargs-valid, args)
				let (oldres oldres-valid) = apply(orig-results, ptuple)
				let (newres) = prim-tuple-type-to-tuple-type-inner(oldres, oldres-valid)
				newres

		forall x : unwrap(type, newargs) -> y : unwrap(type, new-results(x))

prim-func-type-to-func-type foo prim-nil

let func-to-prim-func =
	intrinsic
		""""
			return function(_type, _valid, afn)
				return function(...)
					local args = {...}
					local nargs = select("#", ...)
					local conv_args = terms_gen.declare_array(terms.value)()
					for i = 1, nargs do
						conv_args:append(terms.value.prim(args[i]))
					end
					local res = evaluator.apply_value(afn, terms.value.tuple_value(conv_args))
					if not res:is_prim() then
						error "alicorn function converted to native function has failed to create a real value"
					end
					return res:unwrap_prim()
				end
			end
		:
		prim-func-type
			T : type
			valid : only-accept-prim-funcs(wrap(type, T))
			fn : prim-func-type-to-func-type(T, valid)
			->
			res-fn : T





let prim-if-type = forall (subject : prim-bool) (consequent : prim-type) (alternate : prim-type) -> T : prim-type

let prim-if-wrap = intrinsic
	""""
		local typed = terms.typed_term
		local string_array = terms_gen.declare_array(terms_gen.builtin_string)
		return terms.value.closure(
			"#prim-if-param",
			typed.tuple_elim(
				string_array(
					"#prim-if-subject",
					"#prim-if-consequent",
					"#prim-if-alternate"
				),
				typed.bound_variable(1),
				3,
				typed.prim_if(
					typed.bound_variable(2),
					typed.bound_variable(3),
					typed.bound_variable(4)
				)
			),
			terms.runtime_context()
		)
	:
	wrapped(prim-if-type)
let prim-if = unwrap(prim-if-type, prim-if-wrap)

let tuple-def-type-inner = intrinsic "return terms.value.tuple_defn_type" :
	prim-func-type (U : wrapped(universe)) -> (T : wrapped(prim-type))
let tuple-def-type = lambda ((U : universe))
	let (T) = tuple-def-type-inner(wrap(universe, U))
	unwrap(prim-type, T)
let tuple-type = lambda (U : universe, decls : tuple-def-type(U))
	let inner = intrinsic "return terms.value.tuple_type" :
		prim-func-type (decls : wrapped(tuple-def-type(U))) -> (T : wrapped(prim-type))
	let (T) = inner(wrap(tuple-def-type(U), decls))
	unwrap(prim-type, T)
let prim-tuple-type = lambda (U : universe, decls : tuple-def-type(U))
	let inner = intrinsic "return terms.value.prim_tuple_type" :
		prim-func-type (decls : wrapped(tuple-def-type(U))) -> (T : wrapped(prim-type))
	let (T) = inner(wrap(tuple-def-type(U), decls))
	unwrap(prim-type, T)
let tuple-def-empty = lambda ((U : universe))
	let T = tuple-def-type(U)
	let empty = intrinsic
		""""
			local value_array = terms_gen.declare_array(terms.value)
			return terms.value.enum_value("empty", terms.value.tuple_value(value_array()))
		:
		wrapped(T)
	unwrap(T, empty)
let tuple-def-elem = lambda (
		U    : universe,
		defn : tuple-def-type(U),
		elem : (forall rest : tuple-type(U, defn) -> next : U))
	let inner = intrinsic
		""""
			local value_array = terms_gen.declare_array(terms.value)
			local function tuple_def_elem(defn, elem)
				return terms.value.enum_value("cons", terms.value.tuple_value(value_array(defn, elem)))
			end
			return tuple_def_elem
		:
		prim-func-type
			defn_ : wrapped(tuple-def-type(U)) # aaaa shadowing
			elem  : (wrapped (forall rest : tuple-type(U, defn) -> next : U))
			->
			T     : wrapped(tuple-def-type(U))
	let (T) =
		inner
			wrap(tuple-def-type(U), defn)
			wrap (forall rest : tuple-type(U, defn) -> next : U) elem
	unwrap(tuple-def-type(U), T)
let tuple-of = lambda (U : universe, defn : tuple-def-type(U))
	# ATTN: single parens here means bare lambda syntax
	lambda (t : tuple-type(U, defn))
		t
let prim-tuple-of = lambda (U : universe, defn : tuple-def-type(U))
	intrinsic "return function(...) return ... end" :
		prim-func-type t : prim-tuple-type(U, defn) -> t : prim-tuple-type(U, defn)
let tuple-def-singleton = lambda (U : universe, T : U)
	tuple-def-elem U
		tuple-def-empty U
		lambda (())
			T
let tuple-def-concat = lambda (U : universe, head : tuple-def-type(U), tail : tuple-def-type(U))
	# woah huge intrinsic
	let inner = intrinsic
		""""
			local typed = terms.typed_term
			local typed_array = terms_gen.declare_array(typed)
			local value_array = terms_gen.declare_array(terms.value)
			local string_array = terms_gen.declare_array(terms_gen.builtin_string)
			local function traverse(defn, len, elems)
				len = len or 0
				elems = elems or {}
				local constructor, arg = defn:unwrap_enum_value()
				if constructor == "empty" then
					return len, elems
				elseif constructor == "cons" then
					local elements = arg:unwrap_tuple_value()
					local next_defn = elements[1]
					len = len + 1
					elems[len] = elements[2]
					return traverse(next_defn, len, elems)
				else
					error("unknown tuple defn constructor")
				end
			end
			-- defn is head + (gradually) parts of tail
			-- elem expects only parts of tail, need to wrap to handle head
			-- head_n and tail_n are the lengths of the head and tail component of defn
			local function tuple_def_elem(defn, elem, head_n, head_names, tail_n, tail_names)
				-- in theory the only placeholder name will be in reference to the last
				-- element of head, which is always lost (and sometimes not even asked for)
				local names = string_array()
				for _, name in head_names:ipairs() do
					names:append(name)
				end
				names:append("#_")
				for _, name in tail_names:ipairs() do
					names:append(name)
				end
				-- convert to just tuple of tail
				local tail_args = typed_array()
				for i = 1, tail_n do
					-- 1 for closure argument (passed to tuple_elim)
					-- head_n for head
					tail_args:append(typed.bound_variable(1 + head_n + i))
				end
				local body = typed.tuple_elim(
					names,
					typed.bound_variable(1),
					head_n + tail_n,
					typed.application(typed.literal(elem), typed.tuple_cons(tail_args))
				)
				local elem_wrap = terms.value.closure("#tuple-def-concat", body, terms.runtime_context())
				return terms.value.enum_value("cons", terms.value.tuple_value(value_array(defn, elem_wrap)))
			end
			local function tuple_def_concat(head, tail)
				local head_n, head_elems = traverse(head)
				local tail_n, tail_elems = traverse(tail)
				local head_last = head_elems[1]
				local _, head_code, _ = head_last:unwrap_closure()
				local head_names, _, _, _ = head_code:unwrap_tuple_elim()
				local defn = head
				for i = tail_n, 1, -1 do
					local tail_n_now = tail_n - i
					local elem = tail_elems[i]
					local _, tail_code, _ = elem:unwrap_closure()
					local tail_names, _, _, _ = tail_code:unwrap_tuple_elim()
					defn = tuple_def_elem(defn, elem, head_n, head_names, tail_n_now, tail_names)
				end
				return defn
			end
			return tuple_def_concat
		:
		prim-func-type
			head : wrapped(tuple-def-type(U))
			tail : wrapped(tuple-def-type(U))
			->
			cat : wrapped(tuple-def-type(U))
	let (cat) = inner(wrap(tuple-def-type(U), head), wrap(tuple-def-type(U), tail))
	unwrap(tuple-def-type(U), cat)
let tuple-concat = lambda (
		U    : universe,
		head : tuple-def-type(U),
		tail : tuple-def-type(U),
		hd   : tuple-type(U, head),
		tl   : tuple-type(U, tail))
	let inner = intrinsic
		""""
			local value_array = terms_gen.declare_array(terms.value)
			local function tuple_concat(head, tail)
				local head_elements = head:unwrap_tuple_value()
				local tail_elements = tail:unwrap_tuple_value()
				local new_elements = value_array()
				for _, e in head_elements:ipairs() do
					new_elements:append(e)
				end
				for _, e in tail_elements:ipairs() do
					new_elements:append(e)
				end
				return terms.value.tuple_value(new_elements)
			end
			return tuple_concat
		:
		prim-func-type
			hd : wrapped(tuple-type(U, head))
			tl : wrapped(tuple-type(U, tail))
			->
			cat : wrapped(tuple-type(U, tuple-def-concat(U, head, tail)))
	let (cat) = inner(wrap(tuple-type(U, head), hd), wrap(tuple-type(U, tail), tl))
	unwrap(tuple-type(U, tuple-def-concat(U, head, tail)), cat)
let prim-tuple-concat = lambda (
		U    : universe,
		head : tuple-def-type(U),
		tail : tuple-def-type(U),
		hd   : prim-tuple-type(U, head),
		tl   : prim-tuple-type(U, tail))
	let inner = intrinsic
		""""
			local value_array = terms_gen.declare_array(terms_gen.any_lua_type)
			local function prim_tuple_concat(head, tail)
				local head_elements = head:unwrap_prim_tuple_value()
				local tail_elements = tail:unwrap_prim_tuple_value()
				local new_elements = value_array()
				for _, e in head_elements:ipairs() do
					new_elements:append(e)
				end
				for _, e in tail_elements:ipairs() do
					new_elements:append(e)
				end
				return terms.value.prim_tuple_value(new_elements)
			end
			return prim_tuple_concat
		:
		prim-func-type
			hd : wrapped(prim-tuple-type(U, head))
			tl : wrapped(prim-tuple-type(U, tail))
			->
			cat : wrapped(prim-tuple-type(U, tuple-def-concat(U, head, tail)))
	let (cat) = inner(wrap(prim-tuple-type(U, head), hd), wrap(prim-tuple-type(U, tail), tl))
	unwrap(prim-tuple-type(U, tuple-def-concat(U, head, tail)), cat)

let prim-literal = new-prim-type(new-prim-unique-id("literal"))

let prim-expression-args = new-prim-type(new-prim-unique-id("expression-args"))
let expression-args-new = intrinsic "return alicorn_expressions.ExpressionArgs.new" :
	prim-func-type (goal : prim-goal) (env : prim-environment) -> (args : prim-expression-args)

let prim-shadow-environment = new-prim-type(new-prim-unique-id("shadow-environment"))
let enter-block = intrinsic
	""""
		-- wish environment.enter_block was accessible from internals
		local function enter_block(env)
			return env:enter_block()
		end
		return enter_block
	:
	prim-func-type
		env : prim-environment
		->
		shadowed : prim-shadow-environment
		inner : prim-environment
let exit-block = intrinsic
	""""
		-- wish environment.exit_block was accessible from internals
		local function exit_block(inner, term, shadowed)
			return inner:exit_block(term, shadowed)
		end
		return exit_block
	:
	prim-func-type
		inner : prim-environment
		term : prim-inferrable-term
		shadowed : prim-shadow-environment
		->
		env : prim-environment
		wrapped : prim-inferrable-term

let prim-matcher = new-prim-type-family new-prim-unique-id("matcher")
	forall (userdata : prim-type) (result : tuple-def-type(prim-type)) -> T : prim-type

let nil-handler-type = lambda (userdata : prim-type, result : tuple-def-type(prim-type))
	prim-func-type (ud : userdata) -> r : prim-tuple-type(prim-type, result)
let prim-matcher-is-nil = lambda (userdata : prim-type, result : tuple-def-type(prim-type), accept-handler : nil-handler-type(userdata, result))
	let inner = intrinsic "return metalanguage.isnil" :
		prim-func-type (accept-handler : nil-handler-type(userdata, result)) -> (m : prim-matcher(userdata, result))
	let (m) = inner(accept-handler)
	m

let pair-handler-type = lambda (userdata : prim-type, result : tuple-def-type(prim-type))
	prim-func-type (ud : userdata) (a : prim-syntax) (b : prim-syntax) -> r : prim-tuple-type(prim-type, result)
let prim-matcher-is-pair = lambda (userdata : prim-type, result : tuple-def-type(prim-type), accept-handler : pair-handler-type(userdata, result))
	let inner = intrinsic "return metalanguage.ispair" :
		prim-func-type (accept-handler : pair-handler-type(userdata, result)) -> (m : prim-matcher(userdata, result))
	let (m) = inner(accept-handler)
	m

let symbol-handler-type = lambda (userdata : prim-type, result : tuple-def-type(prim-type))
	prim-func-type (ud : userdata) (symbol : prim-string) -> r : prim-tuple-type(prim-type, result)
let prim-matcher-is-symbol = lambda (userdata : prim-type, result : tuple-def-type(prim-type), accept-handler : symbol-handler-type(userdata, result))
	let inner = intrinsic "return metalanguage.issymbol" :
		prim-func-type (accept-handler : symbol-handler-type(userdata, result)) -> (m : prim-matcher(userdata, result))
	let (m) = inner(accept-handler)
	m

let value-handler-type = lambda (userdata : prim-type, result : tuple-def-type(prim-type))
	prim-func-type (ud : userdata) (val : prim-literal) -> r : prim-tuple-type(prim-type, result)
let prim-matcher-is-value = lambda (userdata : prim-type, result : tuple-def-type(prim-type), accept-handler : value-handler-type(userdata, result))
	let inner = intrinsic "return metalanguage.isvalue" :
		prim-func-type (accept-handler : value-handler-type(userdata, result)) -> (m : prim-matcher(userdata, result))
	let (m) = inner(accept-handler)
	m

let reducible-handler-type = lambda (userdata : prim-type, result2 : tuple-def-type(prim-type), result : tuple-def-type(prim-type))
	# prepend userdata to result2
	let userdata-defn = tuple-def-singleton(prim-type, userdata)
	let params = tuple-def-concat(prim-type, userdata-defn, result2)
	prim-func-type p : prim-tuple-type(prim-type, params) -> r : prim-tuple-type(prim-type, result)
let reducer-type = lambda (userdata : prim-type, storage : tuple-def-type(prim-type), result2 : tuple-def-type(prim-type), result : tuple-def-type(prim-type))
	let accept-handler-type = reducible-handler-type(userdata, result2, result)
	# prepend accept-handler-type to storage
	let accept-handler-defn = tuple-def-singleton(prim-type, accept-handler-type)
	let params = tuple-def-concat(prim-type, accept-handler-defn, storage)
	prim-func-type p : prim-tuple-type(prim-type, params) -> (m : prim-matcher(userdata, result))
let prim-matcher-reducible = lambda (
		userdata       : prim-type,
		storage        : tuple-def-type(prim-type),
		result2        : tuple-def-type(prim-type),
		result         : tuple-def-type(prim-type),
		red            : reducer-type(userdata, storage, result2, result),
		s              : prim-tuple-type(prim-type, storage),
		accept-handler : reducible-handler-type(userdata, result2, result))
	let accept-handler-type = reducible-handler-type(userdata, result2, result)
	let accept-handler-defn = tuple-def-singleton(prim-type, accept-handler-type)
	let red-param-defn = tuple-def-concat(prim-type, accept-handler-defn, storage)
	let red-result-defn = tuple-def-singleton(prim-type, prim-matcher(userdata, result))

	let accept-handler-tuple = prim-tuple-of(prim-type, accept-handler-defn)(accept-handler)
	let red-param = prim-tuple-concat(prim-type, accept-handler-defn, storage, accept-handler-tuple, s)

	# look ma, no intrinsics!
	let (m) = apply(red, red-param)
	m

let failure-handler-type = lambda (userdata : prim-type, result : tuple-def-type(prim-type))
	prim-func-type (ud : userdata) (exception : prim-lua-error) -> r : prim-tuple-type(prim-type, result)

let match-syntax = lambda (
		userdata        : prim-type,
		result          : tuple-def-type(prim-type),
		matchers        : prim-array-type(prim-matcher(userdata, result)),
		failure-handler : failure-handler-type(userdata, result),
		syn             : prim-syntax,
		ud              : userdata)
	let inner = intrinsic
		""""
			local function match_syntax(matchers, failure_handler, syn, ud)
				return syn:match(matchers, failure_handler, ud)
			end
			return match_syntax
		:
		prim-func-type
			matchers        : prim-array-type(prim-matcher(userdata, result))
			failure-handler : failure-handler-type(userdata, result)
			syn             : prim-syntax
			ud              : wrapped(userdata)
			->
			# ugly syntax hack
			r
			:
			prim-tuple-type(prim-type, result)
	inner(matchers, failure-handler, syn, wrap(userdata, ud))

let prim-term-of-inner = intrinsic
	""""
		local function prim_term_of(goal)
			if goal:is_infer() then
				return terms.prim_inferrable_term_type
			elseif goal:is_check() then
				return terms.prim_checkable_term_type
			else
				error("prim-term-of: unknown goal")
			end
		end
		return prim_term_of
	:
	prim-func-type (goal : prim-goal) -> (t : prim-type)
let prim-term-of = lambda ((goal : prim-goal))
	#let (t) = prim-term-of-inner(goal)
	#t
	# FIXME: above errors with: inferred type is a neutral value
	# stub below works for now
	prim-inferrable-term

let operative-handler-type = lambda ((userdata : prim-type))
	forall
		syn : prim-syntax
		env : prim-environment
		ud : userdata
		goal : prim-goal
		->
		term : prim-term-of(goal)
		env : prim-environment

let operative-result-defn = lambda ((goal : prim-goal))
	# read as: (_ : prim-term-of(goal), _ : prim-environment)
	tuple-def-concat prim-type
		tuple-def-singleton(prim-type, prim-term-of(goal))
		tuple-def-singleton(prim-type, prim-environment)

let new-operative = lambda (userdata : prim-type, ud : userdata, handler : operative-handler-type(userdata))
	let inner = intrinsic
		""""
			local function new_operative(userdata, ud, handler)
				return
					terms.value.operative_type(handler, userdata),
					terms.value.operative_value(ud)
			end
			return new_operative
		:
		prim-func-type
			userdata_ : wrapped(prim-type)
			ud : wrapped(userdata)
			handler : wrapped(operative-handler-type(userdata))
			->
			op-type : wrapped(prim-type)
			op : wrapped(unwrap(prim-type, op-type))
	let (op-type, op) =
		inner
			wrap(prim-type, userdata)
			wrap(userdata, ud)
			wrap(operative-handler-type(userdata), handler)

	let op-type = unwrap(prim-type, op-type)
	let op = unwrap(op-type, op)

	# lol look how horrible tuple types are
	let result-defn =
		tuple-def-elem type_(1)
			tuple-def-elem type_(1)
				tuple-def-empty type_(1)
				lambda (())
					prim-type
			lambda ((op-type : prim-type))
				op-type
	tuple-of(type_(1), result-defn)(op-type, op)

let block-reducer-storage-defn = tuple-def-singleton(prim-type, prim-expression-args)

let block-reducer-result2-defn = operative-result-defn # incidentally the same

let block-match-result-defn = lambda ((goal : prim-goal))
	# read as: (ok : prim-bool, _ : prim-if(ok, prim-term-of(goal), prim-lua-error), _ : prim-if(ok, prim-environment, prim-unit))
	# or, more logically: (ok : prim-bool, ...) where:
	# - ok == true:  `...` is prim-term-of(goal), prim-environment
	# - ok == false: `...` is prim-lua-error
	tuple-def-elem prim-type
		tuple-def-elem prim-type
			tuple-def-elem prim-type
				tuple-def-empty prim-type
				lambda (())
					prim-bool
			lambda ((ok : prim-bool))
				prim-if(ok, prim-term-of(goal), prim-lua-error)
		lambda (ok : prim-bool, _ : prim-if(ok, prim-term-of(goal), prim-lua-error))
			# hacky way to do variable-length prim tuples
			prim-if(ok, prim-environment, prim-unit)

let block-reducer = lambda ((goal : prim-goal))
	intrinsic "return alicorn_expressions.block" :
		reducer-type(prim-unit, block-reducer-storage-defn, block-reducer-result2-defn(goal), block-match-result-defn(goal))

let block-match-accept-handler = lambda ((goal : prim-goal))
	intrinsic "return metalanguage.accept_handler" :
		reducible-handler-type(prim-unit, block-reducer-result2-defn(goal), block-match-result-defn(goal))
let block-match-failure-handler = lambda ((goal : prim-goal))
	intrinsic "return metalanguage.failure_handler" :
		failure-handler-type(prim-unit, block-match-result-defn(goal))

# alicorn doesn't have conds or branches yet so...
let error-filter =
	lambda (Tt : prim-type, Tf : prim-type, ok : prim-bool, val-or-err : prim-if(ok, Tt, Tf))
		let inner =
			intrinsic
				""""
					local function error_filter(ok, val_or_err)
						if not ok then
							error(val_or_err)
						end
						return val_or_err
					end
					return error_filter
				:
				prim-func-type (ok : prim-bool) (val-or-err : prim-if(ok, Tt, Tf)) -> (val : Tt)
		let (val) = inner(ok, val-or-err)
		val

let do-impl-type = operative-handler-type(prim-unit)

let do-impl = lambda (syn : prim-syntax, env : prim-environment, ud : prim-unit, goal : prim-goal)
	let (shadowed, inner_env) = enter-block(env)

	let (args) = expression-args-new(goal, inner_env)
	let s = prim-tuple-of(prim-type, block-reducer-storage-defn)(args)

	let matcher-t = prim-matcher(prim-unit, block-match-result-defn(goal))
	let matcher =
		prim-matcher-reducible
			prim-unit
			block-reducer-storage-defn
			block-reducer-result2-defn(goal)
			block-match-result-defn(goal)
			block-reducer(goal)
			s
			block-match-accept-handler(goal)

	let matchers =
		prim-array-set matcher-t
			prim-array-new matcher-t
			1
			matcher

	let (ok, term, inner_env) =
		match-syntax
			prim-unit
			block-match-result-defn(goal)
			matchers
			block-match-failure-handler(goal)
			syn
			ud

	let term = error-filter(prim-term-of(goal), prim-lua-error, ok, term)
	let inner_env = error-filter(prim-environment, prim-unit, ok, inner_env)

	let (env, wrapped) = exit-block(inner_env, term, shadowed)

	tuple-of(prim-type, operative-result-defn(goal))(wrapped, env)

let (do-type, do) = new-operative(prim-unit, prim-nil, do-impl)

let foo = "baz"
let x = do
	let foo = "foo"
	let (foobar) = prim-string-concat(foo, "bar")
	foobar
let (foobarbaz) = prim-string-concat(x, foo)
foobarbaz
