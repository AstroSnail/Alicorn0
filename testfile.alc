# types that need just a little convincing to exist

let prim-string-wrap          = intrinsic "return terms.value.prim_string_type"    : wrapped(prim-type)
let prim-syntax-wrap          = intrinsic "return terms.prim_syntax_type"          : wrapped(prim-type)
let prim-environment-wrap     = intrinsic "return terms.prim_environment_type"     : wrapped(prim-type)
let prim-inferrable-term-wrap = intrinsic "return terms.prim_inferrable_term_type" : wrapped(prim-type)
let prim-lua-error-wrap       = intrinsic "return terms.prim_lua_error_type"       : wrapped(prim-type)

let prim-string          = unwrap(prim-type, prim-string-wrap)
let prim-syntax          = unwrap(prim-type, prim-syntax-wrap)
let prim-environment     = unwrap(prim-type, prim-environment-wrap)
let prim-inferrable-term = unwrap(prim-type, prim-inferrable-term-wrap)
let prim-lua-error       = unwrap(prim-type, prim-lua-error-wrap)

# FIXME: type of universe
# we need to wrap this, and wrap takes a type in star-10
# so we have to settle for star-9
let universe = type_(9)




# setup for custom prim types
# the idea is that values of a type from here may be prims
# suitable for passing into prim functions
# so wrapping/unwrapping is unnecessary

let new-prim-type-inner =
	intrinsic
		""""
			local value_array = terms_gen.declare_array(terms.value)
			local function new_prim_type(name)
				local unique_id = { name = name }
				local basetype = terms.value.prim_user_defined_type(unique_id, value_array())
				return basetype
			end
			return new_prim_type
		:
		prim-func-type (name : prim-string) -> (T : wrapped(prim-type))
let new-prim-type =
	lambda ((name : prim-string))
		let (T) = new-prim-type-inner(name)
		unwrap(prim-type, T)

let new-prim-type-family-inner =
	intrinsic
		""""
			local typed_array = terms_gen.declare_array(terms.typed_term)
			local string_array = terms_gen.declare_array(terms_gen.builtin_string)
			local function new_prim_type_family(name, nparams, sig)
				local unique_id = { name = name }
				local params = typed_array()
				local param_names = string_array()
				for i = 1, nparams do
					params:append(terms.typed_term.bound_variable(i + 1))
					param_names:append("#TEST-2-" .. tostring(i))
				end
				local body = terms.typed_term.tuple_elim(
					param_names,
					terms.typed_term.bound_variable(1),
					nparams,
					terms.typed_term.prim_user_defined_type_cons(
						unique_id,
						params
					)
				)
				return terms.value.closure("#TEST-3", body, terms.runtime_context())
			end
			return new_prim_type_family
		:
		prim-func-type
			name : prim-string
			nparams : prim-number
			signature : wrapped(type_(1))
			->
			family : wrapped(unwrap(type_(1), signature))
let new-prim-type-family =
	lambda 
		(name : prim-string) (nparams : prim-number) (signature : type_(1)) #TODO make nparams not exist by deriving it from the signature
		let (family) = new-prim-type-family-inner(name, nparams, wrap(type_(1), signature))
		unwrap(signature, family)




# some custom prim types

let prim-literal = new-prim-type("literal")

let prim-array-type = new-prim-type-family "array" 1
	forall (T : prim-type) -> T : prim-type

let prim-matcher = new-prim-type-family "matcher" 2
	forall (userdata : prim-type) (result : prim-type) -> T : prim-type

let prim-reducer = new-prim-type-family "reducer" 3
	forall (storage : prim-type) (result : prim-type) (error : prim-type) -> T : prim-type




# implementation of prim-array-type

let prim-array-new =
	lambda ((T : prim-type))
		let inner =
			intrinsic
				""""
					local function array_new()
						return {}
					end
					return array_new
				:
				prim-func-type -> (arr : prim-array-type(T))
		let (arr) = inner()
		arr

let prim-array-set =
	lambda (T : prim-type, arr : prim-array-type(T), index : prim-number, elem : T)
		let inner =
			intrinsic
				""""
					local function array_set(array, index, elem)
						-- we have to clone because can't guarantee input array isn't reused
						-- Yet. growth mindset.
						cloned = {}
						for i, v in ipairs(array) do
							cloned[i] = v
						end
						cloned[index] = elem
						return cloned
					end
					return array_set
				:
				prim-func-type
					arr : prim-array-type(T)
					index : prim-number
					elem : T
					->
					arr : prim-array-type(T)
		let (arr) = inner(arr, index, elem)
		arr

let prim-array-get = 
	lambda (T : prim-type, arr : prim-array-type(T), index : prim-number)
		let inner =
			intrinsic
				""""
					local function array_get(array, index)
						return array[index]
					end
					return array_get
				:
				prim-func-type
					arr : prim-array-type(T)
					index : prim-number
					->
					elem : T
		let (elem) = inner(arr, index)
		(the T elem)




# primitive and reducible matchers, the building blocks of syntax matching
# essentially a lot of busywork making trivial intrinsics and giving them proper types

let nil-handler-type =
	lambda (userdata : prim-type, result : prim-type)
		prim-func-type (ud : userdata) -> (r : result)
let prim-matcher-is-nil =
	lambda (userdata : prim-type, result : prim-type, accept-handler : nil-handler-type(userdata, result))
		let inner = intrinsic "return metalanguage.isnil" :
			prim-func-type (accept-handler : nil-handler-type(userdata, result)) -> (m : prim-matcher(userdata, result))
		let (m) = inner(accept-handler)
		m

let pair-handler-type =
	lambda (userdata : prim-type, result : prim-type)
		prim-func-type (ud : userdata) (a : prim-syntax) (b : prim-syntax) -> (r : result)
let prim-matcher-is-pair =
	lambda (userdata : prim-type, result : prim-type, accept-handler : pair-handler-type(userdata, result))
		let inner = intrinsic "return metalanguage.ispair" :
			prim-func-type (accept-handler : pair-handler-type(userdata, result)) -> (m : prim-matcher(userdata, result))
		let (m) = inner(accept-handler)
		m

let symbol-handler-type =
	lambda (userdata : prim-type, result : prim-type)
		prim-func-type (ud : userdata) (symbol : prim-string) -> (r : result)
let prim-matcher-is-symbol =
	lambda (userdata : prim-type, result : prim-type, accept-handler : symbol-handler-type(userdata, result))
		let inner = intrinsic "return metalanguage.issymbol" :
			prim-func-type (accept-handler : symbol-handler-type(userdata, result)) -> (m : prim-matcher(userdata, result))
		let (m) = inner(accept-handler)
		m

let value-handler-type =
	lambda (userdata : prim-type, result : prim-type)
		prim-func-type (ud : userdata) (val : prim-literal) -> (r : result)
let prim-matcher-is-value =
	lambda (userdata : prim-type, result : prim-type, accept-handler : value-handler-type(userdata, result))
		let inner = intrinsic "return metalanguage.isvalue" :
			prim-func-type (accept-handler : value-handler-type(userdata, result)) -> (m : prim-matcher(userdata, result))
		let (m) = inner(accept-handler)
		m

let reducible-handler-type =
	lambda (userdata : prim-type, product : prim-type, result : prim-type)
		prim-func-type (ud : userdata) (p : product) -> (r : result)
let prim-matcher-reducible =
	lambda (
		storage : prim-type,
		product : prim-type,
		error : prim-type,
		userdata : prim-type,
		result : prim-type,
		red : prim-reducer(storage, product, error),
		s : storage,
		accept-handler : reducible-handler-type(userdata, product, result))

		let inner =
			intrinsic
				""""
					local function reducible(red, s, accept_handler)
						return red(accept_handler, table.unpack(s))
					end
					return reducible
				:
				prim-func-type
					red : prim-reducer(storage, product, error)
					s : wrapped(storage)
					accept-handler : reducible-handler-type(userdata, product, result)
					->
					m : prim-matcher(userdata, result)
		let (m) = inner(red, wrap(storage, s), accept-handler)
		m

let failure-handler-type =
	lambda (userdata : prim-type, result : prim-type)
		prim-func-type (ud : userdata) -> (r : result)

let match-syntax =
	lambda (
		userdata : prim-type,
		result : prim-type,
		matchers : prim-array-type(prim-matcher(userdata, result)),
		failure-handler : failure-handler-type(userdata, result),
		syn : prim-syntax,
		ud : userdata)

		let inner =
			intrinsic
				""""
					local function match_syntax(matchers, failure_handler, syn, ud)
						return syn:match(matchers, failure_handler, ud)
					end
					return match_syntax
				:
				prim-func-type
					matchers : prim-array-type(prim-matcher(userdata, result))
					failure-handler : failure-handler-type(userdata, result)
					syn : prim-syntax
					ud : wrapped(userdata)
					->
					r : wrapped(result)
		let (r) = inner(matchers, failure-handler, syn, wrap(userdata, ud))
		unwrap(result, r)




# explicit tuple types (horrible to use)

let tuple-def-type-inner = intrinsic "return terms.value.tuple_defn_type" :
	prim-func-type (U : wrapped(universe)) -> (T : wrapped(prim-type))
let tuple-def-type =
	lambda ((U : universe))
		let (T) = tuple-def-type-inner(wrap(universe, U))
		unwrap(prim-type, T)
let tuple-type =
	lambda (U : universe, decls : tuple-def-type(U))
		let inner = intrinsic "return terms.value.tuple_type" :
			prim-func-type (decls : wrapped(tuple-def-type(U))) -> (T : wrapped(prim-type))
		let (T) = inner(wrap(tuple-def-type(U), decls))
		unwrap(prim-type, T)
let tuple-def-empty =
	lambda ((U : universe))
		let T = tuple-def-type(U)
		let empty =
			intrinsic
				""""
					local value_array = terms_gen.declare_array(terms.value)
					return terms.value.enum_value("empty", terms.value.tuple_value(value_array()))
				:
				wrapped(T)
		unwrap(T, empty)
let tuple-def-elem =
	lambda (
		U : universe,
		defn : tuple-def-type(U),
		elem : (forall rest : tuple-type(U, defn) -> next : U))

		let inner =
			intrinsic
				""""
					local value_array = terms_gen.declare_array(terms.value)
					local function tuple_def_elem(defn, elem)
						return terms.value.enum_value("cons", terms.value.tuple_value(value_array(defn, elem)))
					end
					return tuple_def_elem
				:
				prim-func-type
					defn_ : wrapped(tuple-def-type(U)) # aaaa shadowing
					elem : (wrapped (forall rest : tuple-type(U, defn) -> next : U))
					->
					T : wrapped(tuple-def-type(U))
		let (T) = inner(wrap(tuple-def-type(U), defn), (wrap (forall rest : tuple-type(U, defn) -> next : U) elem))
		unwrap(tuple-def-type(U), T)




# FIXME: this should be in terms.lua
let expression-args = new-prim-type("expression-args")
# FIXME: currently assuming block returns always inferrable
# this is true now, but a task is out to fix this in lua
# when that happens this should be fixed here too
let block-reducer = intrinsic "return alicorn_expressions.block" :
	prim-reducer
		expression-args
		# lol look how horrible tuple types are
		tuple-type prim-type
			tuple-def-elem prim-type
				tuple-def-elem prim-type
					tuple-def-empty prim-type
					lambda (())
						prim-inferrable-term
				lambda ((_ : prim-inferrable-term))
					prim-environment
		prim-lua-error

let syntax = quote what good fun i'm having
syntax
