let host-arith-binop = (host-func-type (a : host-number, b : host-number) -> ((c : host-number)))
let host-sub = (intrinsic "return function(a, b) return a - b end" : host-arith-binop)

#let host-sub = (intrinsic "return function(a, b) return a - b end" : (host-func-type (a : host-number, b : host-number) -> ((c : host-number))))

#let foo = (record (bar = 5) (baz = 6))
#let subbed = host-sub foo.bar y

let implicit-wrap =
	lambda_implicit (T : type_(10))
		lambda ((x : T))
			wrap T x

let implicit-unwrap =
	lambda_implicit (T : type_(10))
		lambda ((x : wrapped(T)))
			unwrap T x

# FIXME: type of universe
# we need to wrap this, and wrap takes a type in star-10
# so we have to settle for star-9
let universe = type_(9)

let host-bool-wrap            = intrinsic "return terms.value.host_bool_type"      : wrapped(host-type)
let host-string-wrap          = intrinsic "return terms.value.host_string_type"    : wrapped(host-type)
let host-syntax-wrap          = intrinsic "return terms.host_syntax_type"          : wrapped(host-type)
let host-environment-wrap     = intrinsic "return terms.host_environment_type"     : wrapped(host-type)
let host-goal-wrap            = intrinsic "return terms.host_goal_type"            : wrapped(host-type)
let host-inferrable-term-wrap = intrinsic "return terms.host_inferrable_term_type" : wrapped(host-type)
let host-checkable-term-wrap  = intrinsic "return terms.host_checkable_term_type"  : wrapped(host-type)
let host-lua-error-wrap       = intrinsic "return terms.host_lua_error_type"       : wrapped(host-type)

let host-bool            = implicit-unwrap(host-bool-wrap)
let host-string          = implicit-unwrap(host-string-wrap)
let host-syntax          = implicit-unwrap(host-syntax-wrap)
let host-environment     = implicit-unwrap(host-environment-wrap)
let host-goal            = implicit-unwrap(host-goal-wrap)
let host-inferrable-term = implicit-unwrap(host-inferrable-term-wrap)
let host-checkable-term  = implicit-unwrap(host-checkable-term-wrap)
let host-lua-error       = implicit-unwrap(host-lua-error-wrap)

let host-string-concat = intrinsic "return function(a, b) return a .. b end" :
	host-func-type (a : host-string, b : host-string) -> ((c : host-string))

# lmao bootstrapping problem
let host-unique-id-wrap = intrinsic
	"return terms.value.host_user_defined_type({ name = \"unique_id\" }, terms_gen.declare_array(terms.value)())"
	:
	wrapped(host-type)
let host-unique-id = implicit-unwrap(host-unique-id-wrap)
let new-host-unique-id = lambda ((name : host-string))
	let source0 = "return { name = \""
	let (source1) = host-string-concat(source0, name)
	let (source2) = host-string-concat(source1, "\" }")
	intrinsic source2 : host-unique-id

let new-host-type-family = lambda (unique-id : host-unique-id, signature : type_(1))
	let inner = intrinsic
		""""
			local typed_array = terms_gen.declare_array(terms.typed_term)
			local string_array = terms_gen.declare_array(terms_gen.builtin_string)
			local function length(defn, len)
				len = len or 0
				local constructor, arg = defn:unwrap_enum_value()
				if constructor == terms.DeclCons.empty then
					return len
				elseif constructor == terms.DeclCons.cons then
					local elements = arg:unwrap_tuple_value()
					local next_defn = elements[1]
					return length(next_defn, len + 1)
				else
					error("unknown tuple defn constructor")
				end
			end
			local function new_host_type_family(unique_id, sig)
				local param_type, _, _, _ = sig:unwrap_pi()
				local param_decls = param_type:unwrap_tuple_type()
				local nparams = length(param_decls)
				local params = typed_array()
				local param_names = string_array()
				for i = 1, nparams do
					params:append(terms.typed_term.bound_variable(i + 1))
					param_names:append("#type-family-A-" .. tostring(i))
				end
				local body = terms.typed_term.tuple_elim(
					param_names,
					terms.typed_term.bound_variable(1),
					nparams,
					terms.typed_term.host_user_defined_type_cons(
						unique_id,
						params
					)
				)
				return terms.value.closure("#type-family-B", body, terms.runtime_context())
			end
			return new_host_type_family
		:
		host-func-type (unique-id : host-unique-id, signature_ : wrapped(type_(1))) -> ((family    : wrapped(signature)))
	let (family) = inner(unique-id, implicit-wrap(signature))
	implicit-unwrap(family)
let new-host-type = lambda ((unique-id : host-unique-id))
	let Tfam = new-host-type-family unique-id
		forall () -> (T : host-type)
	Tfam()

let host-array-type = new-host-type-family new-host-unique-id("array")
	forall ((T : host-type)) -> (T : host-type)

let host-array-new = lambda ((T : host-type))
	let inner = intrinsic
		""""
			local function array_new()
				return {}
			end
			return array_new
		:
		host-func-type () -> ((arr : host-array-type(T)))
	let (arr) = inner()
	arr
let host-array-set = lambda_implicit (T : host-type)
	lambda (arr : host-array-type(T), index : host-number, elem : T)
		let inner = intrinsic
			""""
				local function array_set(array, index, elem)
					-- we have to clone because can't guarantee input array isn't reused
					-- Yet. growth mindset.
					cloned = {}
					for i, v in ipairs(array) do
						cloned[i] = v
					end
					cloned[index] = elem
					return cloned
				end
				return array_set
			:
			host-func-type (arr   : host-array-type(T), index : host-number, elem  : T) -> ((arr   : host-array-type(T)))
		let (arr) = inner(arr, index, elem)
		arr
let host-array-get = lambda_implicit (T : host-type)
	lambda (arr : host-array-type(T), index : host-number)
		let inner = intrinsic
			""""
				local function array_get(array, index)
					return array[index]
				end
				return array_get
			:
			host-func-type (arr   : host-array-type(T), index : host-number) -> ((elem  : T))
		let (elem) = inner(arr, index)
		elem

let host-file-read =
	intrinsic
		""""
			local fs = require 'fs'
			return fs.readFileSync
		:
		host-func-type ((fname : host-string)) -> ((content : host-string))

let terms-gen-array = new-host-type(new-host-unique-id("terms-gen-array"))

let void =
	implicit-unwrap
		intrinsic
			""""
				local decl = terms.empty
				local basetype = terms.value.enum_type(decl)
				return basetype
			:
			wrapped type

let host-unit = new-host-type(new-host-unique-id("host-unit"))
let host-nil = intrinsic "return nil" : host-unit

let only-accept-host-tuples-inner-host =
	intrinsic
		""""
			local function check_host_tuple(subject, consequent, alternate)
				if subject:is_host_tuple_type() then
					return consequent
				else
					return alternate
				end
			end
			return check_host_tuple
		:
		host-func-type (subject : wrapped(type), consequent : wrapped(host-type), alternate : wrapped(host-type)) -> ((result : wrapped(host-type)))

let only-accept-host-tuples-inner =
	lambda (subject : wrapped(type), consequent : host-type, alternate : host-type)
		let (res) =
			only-accept-host-tuples-inner-host
				subject
				implicit-wrap consequent
				implicit-wrap alternate
		implicit-unwrap res
let only-accept-host-tuples =
	lambda ((subject : wrapped(type)))
		only-accept-host-tuples-inner
			subject
			host-unit
			wrapped void

let host-tuple-type-to-tuple-type-inner =
	intrinsic
		""""
			local function host_tuple_to_tuple(host_tuple_type)
				local decls = host_tuple_type:unwrap_host_tuple_type()
				-- this conversion happens to work since the eliminator for host tuples and tuples is the same term
				local newbasetype = terms.value.tuple_type(decls)
				return newbasetype
			end
			return host_tuple_to_tuple
		:
		host-func-type (t : wrapped(type), valid : only-accept-host-tuples(t)) -> ((res : wrapped(type)))

let host-tuple-type-to-tuple-type =
	lambda (t : wrapped(type), valid : only-accept-host-tuples(t))
		let (res) = host-tuple-type-to-tuple-type-inner(t, valid)
		res

let host-tuple-to-tuple-inner =
	intrinsic
		""""
			return function(_type, _valid, val)
				local elems = val:unwrap_host_tuple_value()
				local vals = terms_gen.delcare_array(terms.value)()
				for _, v in ipairs(elems) do
					vals:append(terms.value.host_value(v))
				end
				return terms.value.tuple_value(vals)
			end
		:
		host-func-type (t : wrapped(type), valid : only-accept-host-tuples(t), val : wrapped(implicit-unwrap(t))) -> ((res : wrapped(implicit-unwrap(host-tuple-type-to-tuple-type(t, valid)))))

let host-tuple-to-tuple =
	lambda (t : wrapped(type), valid : only-accept-host-tuples(t), val : implicit-unwrap(t))
		let (res) = host-tuple-to-tuple-inner(t, valid, implicit-wrap(val))
		implicit-unwrap(res)

let tuple-to-host-tuple-inner =
	intrinsic
		""""
			return function(_type, _valid, val)
				local elems = val:unwrap_tuple_value()
				local leading = terms_gen.declare_array(terms_gen.any_lua_type)()
				local stuck = false
				local stuck_elem = nil
				local trailing = terms_gen.declare_ array(terms.value)()
				for _, v in ipairs(elems) do
					if stuck then
						trailing:append(v)
					elseif v:is_host_value() then
						leading:append(v:unwrap_host_value())
					elseif v:is_neutral() then
						stuck, stuck_elem = true, v:unwrap_neutral()
					else
						error "found an element in a tuple being converted to host-tuple that was neither host nor neutral"
					end
				end
				if not stuck then
					return terms.value.host_tuple_value(leading)
				else
					return terms.value.neutral(terms.neutral_value.host_tuple_stuck(leading, stuck_elem, trailing))
				end
			end
		:
		host-func-type (t : wrapped(type), valid : only-accept-host-tuples(t), val : wrapped(implicit-unwrap(host-tuple-type-to-tuple-type(t, valid)))) -> ((res : wrapped(implicit-unwrap(t))))

let tuple-to-host-tuple =
	lambda (t : wrapped(type), valid : only-accept-host-tuples(t), val : implicit-unwrap(host-tuple-type-to-tuple-type(t, valid)))
		let (res) = tuple-to-host-tuple-inner(t, valid, implicit-wrap(val))
		implicit-unwrap(res)

let only-accept-host-funcs-inner-host =
	intrinsic
		""""
			local function check_host_func(subject, consequent, alternate)
				if subject:is_host_function_type() then
					return consequent
				else
					return alternate
				end
			end
			return check_host_func
		:
		host-func-type (subject : wrapped(type), consequent : wrapped(host-type), alternate : wrapped(host-type)) -> ((result : wrapped(host-type)))

let only-accept-host-funcs-inner =
	lambda (subject : wrapped(type), consequent : host-type, alternate : host-type)
		let (res) =
			only-accept-host-funcs-inner-host
				subject
				implicit-wrap consequent
				implicit-wrap alternate
		implicit-unwrap res
let only-accept-host-funcs =
	lambda ((subject : wrapped(type)))
		only-accept-host-funcs-inner
			subject
			host-unit
			wrapped void

let get-host-func-arg-inner =
	intrinsic
		""""
			local function get_host_func_arg(subject, valid)
				local param_type, result_type = subject:unwrap_host_function_type()
				return param_type, nil
			end
			return get_host_func_arg
		:
		host-func-type (subject : wrapped(type), valid : only-accept-host-funcs(subject)) -> (result : wrapped(type), valid : only-accept-host-tuples(result))

let just-args =
	lambda (subject : wrapped(type), valid : only-accept-host-funcs(subject))
		let (result, valid) = get-host-func-arg-inner(subject, valid)
		result

let func-conv-res-type = 
	lambda ((argtype : wrapped(type)))
		# FIXME: implicit-unwrap here causes nearest_star_level to fail
		#forall (arg : implicit-unwrap(argtype)) -> (res : wrapped(type), valid : only-accept-host-tuples(res))
		forall (arg : unwrap(type, argtype)) -> (res : wrapped(type), valid : only-accept-host-tuples(res))

let get-host-func-res-inner =
	intrinsic
		""""
			local function get_host_func_res(subject, valid)
				local param_type, result_type = subject:unwrap_host_function_type()
				local typed_array = terms_gen.declare_array(terms.typed_term)
				local tuple_build = terms.typed_term.tuple_cons(
					typed_array(
						terms.typed_term.host_wrap(
							terms.typed_term.application(
								terms.typed_term.bound_variable(1),
								terms.typed_term.bound_variable(2)
							)
						),
						terms.typed_term.literal(terms.value.host_value(nil))
					)
				)
				local ctx = terms.runtime_context():append(result_type)
				return terms.value.closure("#TEST-1", tuple_build, ctx)
			end
			return get_host_func_res
		:
		host-func-type (subject : wrapped(type), valid : only-accept-host-funcs(subject)) -> ((results : wrapped(func-conv-res-type(just-args(subject, valid)))))
						

let foo =
	host-func-type (x : host-number, y : host-number) -> ((res : host-number))

foo

let (oldargs oldargs-valid) = get-host-func-arg-inner(implicit-wrap(foo), host-nil)
let (newargs) = host-tuple-type-to-tuple-type-inner(oldargs, oldargs-valid)
newargs

let id_type = forall (name : host-number) -> (name : host-number)

let id_num = lambda (T : host-number)
	T

(the id_type id_num)

let sub = lambda (x : host-number, y : host-number)
	let (res) = host-sub(x, y)
	res

let sub_type = forall (x : host-number, y : host-number) -> (res : host-number)

(the sub_type sub)

let (orig-results) = get-host-func-res-inner(implicit-wrap(foo), host-nil)
# FIXME: implicit-unwrap here causes new-results to fail due to trying
# to apply() something whose type is a metavariable
let orig-results = unwrap(func-conv-res-type(oldargs), orig-results)
#let orig-results = implicit-unwrap(orig-results)
let new-results =
	lambda ((args : implicit-unwrap(newargs)))
		let ptuple = tuple-to-host-tuple(oldargs, oldargs-valid, args)
		let orig-results-res = apply(orig-results, ptuple)
		let (newres valid) = orig-results-res
		newres

let host-func-type-to-func-type =
	lambda (T : type, valid : only-accept-host-funcs(implicit-wrap(T)))
		let (oldargs oldargs-valid) = get-host-func-arg-inner(implicit-wrap(T), valid)
		let (newargs) = host-tuple-type-to-tuple-type-inner(oldargs, oldargs-valid)
		let (orig-results-wrapped) = get-host-func-res-inner(implicit-wrap(T), valid)
		# FIXME: implicit-unwrap here causes new-results to fail due to trying
		# to apply() something whose type is a metavariable
		let orig-results = unwrap(func-conv-res-type(oldargs), orig-results-wrapped)
		#let orig-results = implicit-unwrap(orig-results-wrapped)
		
		let new-results =
			lambda ((args : implicit-unwrap(newargs)))
				let ptuple = tuple-to-host-tuple(oldargs, oldargs-valid, args)
				let (oldres oldres-valid) = apply(orig-results, ptuple)
				let (newres) = host-tuple-type-to-tuple-type-inner(oldres, oldres-valid)
				newres

		# FIXME: implicit-unwrap here causes nearest_star_level to fail
		#forall (x : implicit-unwrap(newargs)) -> (y : implicit-unwrap(new-results(x)))
		forall (x : unwrap(type, newargs)) -> (y : unwrap(type, new-results(x)))

host-func-type-to-func-type foo host-nil

let func-to-host-func =
	intrinsic
		""""
			return function(_type, _valid, afn)
				return function(...)
					local args = {...}
					local nargs = select("#", ...)
					local conv_args = terms_gen.declare_array(terms.value)()
					for i = 1, nargs do
						conv_args:append(terms.value.host_value(args[i]))
					end
					local res = evaluator.apply_value(afn, terms.value.tuple_value(conv_args))
					if not res:is_host_value() then
						error "alicorn function converted to native function has failed to create a real value"
					end
					return res:unwrap_host_value()
				end
			end
		:
		host-func-type (T : type, valid : only-accept-host-funcs(implicit-wrap(T)), fn : host-func-type-to-func-type(T, valid)) -> ((res-fn : T))





let host-if-type = forall (subject : host-bool, consequent : host-type, alternate : host-type) -> (T : host-type)

let host-if-wrap = intrinsic
	""""
		local typed = terms.typed_term
		local string_array = terms_gen.declare_array(terms_gen.builtin_string)
		return terms.value.closure(
			"#host-if-param",
			typed.tuple_elim(
				string_array(
					"#host-if-subject",
					"#host-if-consequent",
					"#host-if-alternate"
				),
				typed.bound_variable(1),
				3,
				typed.host_if(
					typed.bound_variable(2),
					typed.bound_variable(3),
					typed.bound_variable(4)
				)
			),
			terms.runtime_context()
		)
	:
	wrapped(host-if-type)
let host-if = implicit-unwrap(host-if-wrap)

let tuple-def-type-inner = intrinsic "return terms.value.tuple_defn_type" :
	host-func-type ((U : wrapped(universe))) -> ((T : wrapped(host-type)))
let tuple-def-type = lambda ((U : universe))
	let (T) = tuple-def-type-inner(implicit-wrap(U))
	implicit-unwrap(T)
let tuple-type = lambda (U : universe, decls : tuple-def-type(U))
	let inner = intrinsic "return terms.value.tuple_type" :
		host-func-type ((decls : wrapped(tuple-def-type(U)))) -> ((T : wrapped(host-type)))
	let (T) = inner(implicit-wrap(decls))
	# FIXME: implicit-unwrap here causes nearest_star_level to fail in tuple-def-elem
	#implicit-unwrap(T)
	unwrap(host-type, T)
let host-tuple-type = lambda (U : universe, decls : tuple-def-type(U))
	let inner = intrinsic "return terms.value.host_tuple_type" :
		host-func-type ((decls : wrapped(tuple-def-type(U)))) -> ((T : wrapped(host-type)))
	let (T) = inner(implicit-wrap(decls))
	implicit-unwrap(T)
# FIXME: these implicit functions don't seem to work at all
let tuple-type-implicit = lambda_implicit (U : universe)
	lambda (decls : tuple-def-type(U))
		let inner = intrinsic "return terms.value.tuple_type" :
			host-func-type ((decls : wrapped(tuple-def-type(U)))) -> ((T : wrapped(host-type)))
		let (T) = inner(implicit-wrap(decls))
		# FIXME: implicit-unwrap here causes nearest_star_level to fail in tuple-def-elem
		#implicit-unwrap(T)
		unwrap(host-type, T)
let host-tuple-type-implicit = lambda_implicit (U : universe)
	lambda (decls : tuple-def-type(U))
		let inner = intrinsic "return terms.value.host_tuple_type" :
			host-func-type ((decls : wrapped(tuple-def-type(U)))) -> ((T : wrapped(host-type)))
		let (T) = inner(implicit-wrap(decls))
		implicit-unwrap(T)
let tuple-def-empty = lambda ((U : universe))
	let T = tuple-def-type(U)
	let empty = intrinsic "return terms.empty" : wrapped(T)
	implicit-unwrap(empty)
let jank-it-up = lambda (U : universe, defn : tuple-def-type(U))
	# FIXME: when tuple-type-implicit works, unjank this
	forall (rest : tuple-type(U, defn)) -> (next : U)
	#forall (rest : tuple-type-implicit(defn)) -> (next : U)
let tuple-def-elem = lambda (
		U    : universe,
		defn : tuple-def-type(U),
		elem : jank-it-up(U, defn))
	let inner = intrinsic "return terms.cons" :
		host-func-type (
			defn_ : wrapped(tuple-def-type(U)), # aaaa shadowing
			elem  : (wrapped (forall (rest : tuple-type(U, defn)) -> (next : U))))
			->
			((T     : wrapped(tuple-def-type(U))))
	let (T) =
		inner
			implicit-wrap(defn)
			implicit-wrap(elem)
	implicit-unwrap(T)
let tuple-of = lambda (U : universe, defn : tuple-def-type(U))
	# ATTN: single parens here means bare lambda syntax
	lambda (t : tuple-type(U, defn))
		t
let host-tuple-of = lambda (U : universe, defn : tuple-def-type(U))
	intrinsic "return function(...) return ... end" :
		host-func-type (t : host-tuple-type(U, defn)) -> (t : host-tuple-type(U, defn))
let tuple-def-singleton = lambda (U : universe, T : U)
	tuple-def-elem U
		tuple-def-empty U
		lambda ()
			T
let tuple-def-concat = lambda (U : universe, head : tuple-def-type(U), tail : tuple-def-type(U))
	# woah huge intrinsic
	let inner = intrinsic
		""""
			local typed = terms.typed_term
			local typed_array = terms_gen.declare_array(typed)
			local string_array = terms_gen.declare_array(terms_gen.builtin_string)
			local function traverse(defn, len, elems)
				len = len or 0
				elems = elems or {}
				local constructor, arg = defn:unwrap_enum_value()
				if constructor == terms.DeclCons.empty then
					return len, elems
				elseif constructor == terms.DeclCons.cons then
					local elements = arg:unwrap_tuple_value()
					local next_defn = elements[1]
					len = len + 1
					elems[len] = elements[2]
					return traverse(next_defn, len, elems)
				else
					error("unknown tuple defn constructor")
				end
			end
			-- defn is head + (gradually) parts of tail
			-- elem expects only parts of tail, need to wrap to handle head
			-- head_n and tail_n are the lengths of the head and tail component of defn
			local function tuple_def_elem(defn, elem, head_n, head_names, tail_n, tail_names)
				-- in theory the only placeholder name will be in reference to the last
				-- element of head, which is always lost (and sometimes not even asked for)
				local names = string_array()
				for _, name in head_names:ipairs() do
					names:append(name)
				end
				names:append("#_")
				for _, name in tail_names:ipairs() do
					names:append(name)
				end
				-- convert to just tuple of tail
				local tail_args = typed_array()
				for i = 1, tail_n do
					-- 1 for closure argument (passed to tuple_elim)
					-- head_n for head
					tail_args:append(typed.bound_variable(1 + head_n + i))
				end
				local body = typed.tuple_elim(
					names,
					typed.bound_variable(1),
					head_n + tail_n,
					typed.application(typed.literal(elem), typed.tuple_cons(tail_args))
				)
				local elem_wrap = terms.value.closure("#tuple-def-concat", body, terms.runtime_context())
				return terms.cons(defn, elem_wrap)
			end
			local function tuple_def_concat(head, tail)
				local head_n, head_elems = traverse(head)
				local tail_n, tail_elems = traverse(tail)
				local head_last = head_elems[1]
				local _, head_code, _ = head_last:unwrap_closure()
				local head_names, _, _, _ = head_code:unwrap_tuple_elim()
				local defn = head
				for i = tail_n, 1, -1 do
					local tail_n_now = tail_n - i
					local elem = tail_elems[i]
					local _, tail_code, _ = elem:unwrap_closure()
					local tail_names, _, _, _ = tail_code:unwrap_tuple_elim()
					defn = tuple_def_elem(defn, elem, head_n, head_names, tail_n_now, tail_names)
				end
				return defn
			end
			return tuple_def_concat
		:
		host-func-type (head : wrapped(tuple-def-type(U)), tail : wrapped(tuple-def-type(U))) -> ((cat : wrapped(tuple-def-type(U))))
	let (cat) = inner(implicit-wrap(head), implicit-wrap(tail))
	implicit-unwrap(cat)
let tuple-concat = lambda (
		U    : universe,
		head : tuple-def-type(U),
		tail : tuple-def-type(U),
		hd   : tuple-type(U, head),
		tl   : tuple-type(U, tail))
	let inner = intrinsic
		""""
			local value_array = terms_gen.declare_array(terms.value)
			local function tuple_concat(head, tail)
				local head_elements = head:unwrap_tuple_value()
				local tail_elements = tail:unwrap_tuple_value()
				local new_elements = value_array()
				for _, e in head_elements:ipairs() do
					new_elements:append(e)
				end
				for _, e in tail_elements:ipairs() do
					new_elements:append(e)
				end
				return terms.value.tuple_value(new_elements)
			end
			return tuple_concat
		:
		host-func-type (hd : wrapped(tuple-type(U, head)), tl : wrapped(tuple-type(U, tail))) -> ((cat : wrapped(tuple-type(U, tuple-def-concat(U, head, tail)))))
	let (cat) = inner(implicit-wrap(hd), implicit-wrap(tl))
	implicit-unwrap(cat)
let host-tuple-concat = lambda (
		U    : universe,
		head : tuple-def-type(U),
		tail : tuple-def-type(U),
		hd   : host-tuple-type(U, head),
		tl   : host-tuple-type(U, tail))
	let inner = intrinsic
		""""
			local value_array = terms_gen.declare_array(terms_gen.any_lua_type)
			local function host_tuple_concat(head, tail)
				local head_elements = head:unwrap_host_tuple_value()
				local tail_elements = tail:unwrap_host_tuple_value()
				local new_elements = value_array()
				for _, e in head_elements:ipairs() do
					new_elements:append(e)
				end
				for _, e in tail_elements:ipairs() do
					new_elements:append(e)
				end
				return terms.value.host_tuple_value(new_elements)
			end
			return host_tuple_concat
		:
		host-func-type (hd : wrapped(host-tuple-type(U, head)), tl : wrapped(host-tuple-type(U, tail))) -> ((cat : wrapped(host-tuple-type(U, tuple-def-concat(U, head, tail)))))
	let (cat) = inner(implicit-wrap(hd), implicit-wrap(tl))
	implicit-unwrap(cat)

let host-literal = new-host-type(new-host-unique-id("literal"))

let host-expression-args = new-host-type(new-host-unique-id("expression-args"))
let expression-args-new = intrinsic "return alicorn_expressions.ExpressionArgs.new" :
	host-func-type (goal : host-goal, env : host-environment) -> ((args : host-expression-args))

let host-shadow-environment = new-host-type(new-host-unique-id("shadow-environment"))
let enter-block = intrinsic
	""""
		-- wish environment.enter_block was accessible from internals
		local function enter_block(env)
			return env:enter_block()
		end
		return enter_block
	:
	host-func-type ((env : host-environment)) -> (shadowed : host-shadow-environment, inner : host-environment)
let exit-block = intrinsic
	""""
		-- wish environment.exit_block was accessible from internals
		local function exit_block(inner, term, shadowed)
			return inner:exit_block(term, shadowed)
		end
		return exit_block
	:
	host-func-type (inner : host-environment, term : host-inferrable-term, shadowed : host-shadow-environment) -> (env : host-environment, wrapped : host-inferrable-term)

let host-matcher = new-host-type-family new-host-unique-id("matcher")
	forall (userdata : host-type, result : tuple-def-type(host-type)) -> (T : host-type)

let nil-handler-type = lambda (userdata : host-type, result : tuple-def-type(host-type))
	host-func-type ((ud : userdata)) -> (r : host-tuple-type(host-type, result))
let host-matcher-is-nil = lambda (userdata : host-type, result : tuple-def-type(host-type), accept-handler : nil-handler-type(userdata, result))
	let inner = intrinsic "return metalanguage.isnil" :
		host-func-type ((accept-handler : nil-handler-type(userdata, result))) -> ((m : host-matcher(userdata, result)))
	let (m) = inner(accept-handler)
	m

let pair-handler-type = lambda (userdata : host-type, result : tuple-def-type(host-type))
	host-func-type (ud : userdata, a : host-syntax, b : host-syntax) -> (r : host-tuple-type(host-type, result))
let host-matcher-is-pair = lambda (userdata : host-type, result : tuple-def-type(host-type), accept-handler : pair-handler-type(userdata, result))
	let inner = intrinsic "return metalanguage.ispair" :
		host-func-type ((accept-handler : pair-handler-type(userdata, result))) -> ((m : host-matcher(userdata, result)))
	let (m) = inner(accept-handler)
	m

let symbol-handler-type = lambda (userdata : host-type, result : tuple-def-type(host-type))
	host-func-type (ud : userdata, symbol : host-string) -> (r : host-tuple-type(host-type, result))
let host-matcher-is-symbol = lambda (userdata : host-type, result : tuple-def-type(host-type), accept-handler : symbol-handler-type(userdata, result))
	let inner = intrinsic "return metalanguage.issymbol" :
		host-func-type ((accept-handler : symbol-handler-type(userdata, result))) -> ((m : host-matcher(userdata, result)))
	let (m) = inner(accept-handler)
	m

let value-handler-type = lambda (userdata : host-type, result : tuple-def-type(host-type))
	host-func-type (ud : userdata, val : host-literal) -> (r : host-tuple-type(host-type, result))
let host-matcher-is-value = lambda (userdata : host-type, result : tuple-def-type(host-type), accept-handler : value-handler-type(userdata, result))
	let inner = intrinsic "return metalanguage.isvalue" :
		host-func-type ((accept-handler : value-handler-type(userdata, result))) -> ((m : host-matcher(userdata, result)))
	let (m) = inner(accept-handler)
	m

let reducible-handler-type = lambda (userdata : host-type, result2 : tuple-def-type(host-type), result : tuple-def-type(host-type))
	# prepend userdata to result2
	let userdata-defn = tuple-def-singleton(host-type, userdata)
	let params = tuple-def-concat(host-type, userdata-defn, result2)
	host-func-type (p : host-tuple-type(host-type, params)) -> (r : host-tuple-type(host-type, result))
let reducer-type = lambda (userdata : host-type, storage : tuple-def-type(host-type), result2 : tuple-def-type(host-type), result : tuple-def-type(host-type))
	let accept-handler-type = reducible-handler-type(userdata, result2, result)
	# prepend accept-handler-type to storage
	let accept-handler-defn = tuple-def-singleton(host-type, accept-handler-type)
	let params = tuple-def-concat(host-type, accept-handler-defn, storage)
	host-func-type (p : host-tuple-type(host-type, params)) -> ((m : host-matcher(userdata, result)))
let host-matcher-reducible = lambda (
		userdata       : host-type,
		storage        : tuple-def-type(host-type),
		result2        : tuple-def-type(host-type),
		result         : tuple-def-type(host-type),
		red            : reducer-type(userdata, storage, result2, result),
		s              : host-tuple-type(host-type, storage),
		accept-handler : reducible-handler-type(userdata, result2, result))
	let accept-handler-type = reducible-handler-type(userdata, result2, result)
	let accept-handler-defn = tuple-def-singleton(host-type, accept-handler-type)
	let red-param-defn = tuple-def-concat(host-type, accept-handler-defn, storage)
	let red-result-defn = tuple-def-singleton(host-type, host-matcher(userdata, result))

	let accept-handler-tuple = host-tuple-of(host-type, accept-handler-defn)(accept-handler)
	let red-param = host-tuple-concat(host-type, accept-handler-defn, storage, accept-handler-tuple, s)

	# look ma, no intrinsics!
	let (m) = apply(red, red-param)
	m

let failure-handler-type = lambda (userdata : host-type, result : tuple-def-type(host-type))
	host-func-type (ud : userdata, exception : host-lua-error) -> (r : host-tuple-type(host-type, result))

let match-syntax = lambda (
		userdata        : host-type,
		result          : tuple-def-type(host-type),
		matchers        : host-array-type(host-matcher(userdata, result)),
		failure-handler : failure-handler-type(userdata, result),
		syn             : host-syntax,
		ud              : userdata)
	let inner = intrinsic
		""""
			local function match_syntax(matchers, failure_handler, syn, ud)
				return syn:match(matchers, failure_handler, ud)
			end
			return match_syntax
		:
		host-func-type (matchers        : host-array-type(host-matcher(userdata, result)), failure-handler : failure-handler-type(userdata, result), syn             : host-syntax, ud              : wrapped(userdata)) -> (r : host-tuple-type(host-type, result))
	inner(matchers, failure-handler, syn, implicit-wrap(ud))

let host-term-of-inner = intrinsic
	""""
		local function host_term_of(goal)
			if goal:is_infer() then
				return terms.host_inferrable_term_type
			elseif goal:is_check() then
				return terms.host_checkable_term_type
			else
				error("host-term-of: unknown goal")
			end
		end
		return host_term_of
	:
	host-func-type ((goal : host-goal)) -> ((t : wrapped(host-type)))
let host-term-of = lambda ((goal : host-goal))
	let (t) = host-term-of-inner(goal)
	implicit-unwrap(t)
let goalify-inferrable = intrinsic
	""""
		local function goalify_inferrable(goal, inferrable)
			if goal:is_infer() then
				return inferrable
			elseif goal:is_check() then
				return terms.checkable_term.inferrable(inferrable)
			else
				error("goalify-inferrable: unknown goal")
			end
		end
		return goalify_inferrable
	:
	host-func-type (goal : host-goal, inferrable : host-inferrable-term) -> ((term : host-term-of(goal)))

let operative-handler-type = lambda ((userdata : host-type))
	forall (syn : host-syntax, env : host-environment, ud : userdata, goal : host-goal) -> (term : host-term-of(goal), env : host-environment)

let operative-result-defn = lambda ((goal : host-goal))
	# read as: (term : host-term-of(goal), env : host-environment)
	tuple-def-concat host-type
		tuple-def-singleton(host-type, host-term-of(goal))
		tuple-def-singleton(host-type, host-environment)

let new-operative = lambda (userdata : host-type, ud : userdata, handler : operative-handler-type(userdata))
	let inner = intrinsic
		""""
			local function new_operative(userdata, ud, handler)
				return
					terms.value.operative_type(handler, userdata),
					terms.value.operative_value(ud)
			end
			return new_operative
		:
		host-func-type (userdata_ : wrapped(host-type), ud : wrapped(userdata), handler : wrapped(operative-handler-type(userdata))) -> (op-type : wrapped(host-type), op : wrapped(implicit-unwrap(op-type)))
	let (op-type, op) =
		inner
			implicit-wrap(userdata)
			implicit-wrap(ud)
			implicit-wrap(handler)

	let op-type = implicit-unwrap(op-type)
	let op = implicit-unwrap(op)

	# lol look how horrible tuple types are
	# read as: (op-type : host-type, op : op-type)
	let result-defn =
		tuple-def-elem type_(1)
			tuple-def-elem type_(1)
				tuple-def-empty type_(1)
				lambda ()
					host-type
			lambda ((op-type : host-type))
				op-type
	tuple-of(type_(1), result-defn)(op-type, op)

let block-reducer-storage-defn = tuple-def-singleton(host-type, host-expression-args)

let block-reducer-result2-defn = operative-result-defn # incidentally the same

let block-match-result-defn = lambda ((goal : host-goal))
	# read as: (ok : host-bool, _ : host-if(ok, host-term-of(goal), host-lua-error), _ : host-if(ok, host-environment, host-unit))
	# or, more logically: (ok : host-bool, ...) where:
	# - ok == true:  `...` is host-term-of(goal), host-environment
	# - ok == false: `...` is host-lua-error
	tuple-def-elem host-type
		tuple-def-elem host-type
			tuple-def-elem host-type
				tuple-def-empty host-type
				lambda ()
					host-bool
			lambda ((ok : host-bool))
				host-if(ok, host-term-of(goal), host-lua-error)
		lambda (ok : host-bool, _ : host-if(ok, host-term-of(goal), host-lua-error))
			# hacky way to do variable-length host tuples
			host-if(ok, host-environment, host-unit)

let block-reducer = lambda ((goal : host-goal))
	intrinsic "return alicorn_expressions.block" :
		reducer-type(host-unit, block-reducer-storage-defn, block-reducer-result2-defn(goal), block-match-result-defn(goal))

let block-match-accept-handler = lambda ((goal : host-goal))
	intrinsic "return metalanguage.accept_handler" :
		reducible-handler-type(host-unit, block-reducer-result2-defn(goal), block-match-result-defn(goal))
let block-match-failure-handler = lambda ((goal : host-goal))
	intrinsic "return metalanguage.failure_handler" :
		failure-handler-type(host-unit, block-match-result-defn(goal))

# alicorn doesn't have conds or branches yet so...
let error-filter =
	lambda (Tt : host-type, Tf : host-type, ok : host-bool, val-or-err : host-if(ok, Tt, Tf))
		let inner = intrinsic
			""""
				local function error_filter(ok, val_or_err)
					if not ok then
						error(val_or_err)
					end
					return val_or_err
				end
				return error_filter
			:
			host-func-type (ok : host-bool, val-or-err : host-if(ok, Tt, Tf)) -> ((val : Tt))
		let (val) = inner(ok, val-or-err)
		val

let goal-infer = intrinsic "return terms.expression_goal.infer" : host-goal

let do-impl-type = operative-handler-type(host-unit)

let do-impl = lambda (syn : host-syntax, env : host-environment, ud : host-unit, goal : host-goal)
	let (shadowed, inner_env) = enter-block(env)

	let (args) = expression-args-new(goal-infer, inner_env)
	let s = host-tuple-of(host-type, block-reducer-storage-defn)(args)

	let matcher-t = host-matcher(host-unit, block-match-result-defn(goal-infer))
	let matcher =
		host-matcher-reducible
			host-unit
			block-reducer-storage-defn
			block-reducer-result2-defn(goal-infer)
			block-match-result-defn(goal-infer)
			block-reducer(goal-infer)
			s
			block-match-accept-handler(goal-infer)

	let matchers =
		host-array-set
			host-array-new matcher-t
			1
			matcher

	let (ok, term, inner_env) =
		match-syntax
			host-unit
			block-match-result-defn(goal-infer)
			matchers
			block-match-failure-handler(goal-infer)
			syn
			host-nil

	let term = error-filter(host-term-of(goal-infer), host-lua-error, ok, term)
	let inner_env = error-filter(host-environment, host-unit, ok, inner_env)

	let (env, wrapped) = exit-block(inner_env, term, shadowed)

	let (wrapped) = goalify-inferrable(goal, wrapped)

	tuple-of(host-type, operative-result-defn(goal))(wrapped, env)

let (do-type, do) = new-operative(host-unit, host-nil, do-impl)

let foo = "baz"
let x = do
	let foo = "foo"
	let (foobar) = host-string-concat(foo, "bar")
	foobar
let (foobarbaz) = host-string-concat(x, foo)
foobarbaz

let tupleof-ascribed-names-reducer-thread-type = new-host-type(new-host-unique-id("tupleof-ascribed-names-reducer-thread"))
let tupleof-ascribed-names-reducer-thread-type-get-names = intrinsic
	""""
		local function get_names(thread)
			return thread.names
		end
		return get_names
	:
	host-func-type ((thread : tupleof-ascribed-names-reducer-thread-type)) -> ((names : terms-gen-array))
let tupleof-ascribed-names-reducer-thread-type-get-args = intrinsic
	""""
		local function get_args(thread)
			return thread.args
		end
		return get_args
	:
	host-func-type ((thread : tupleof-ascribed-names-reducer-thread-type)) -> ((args : host-inferrable-term))
let tupleof-ascribed-names-reducer-thread-type-get-env = intrinsic
	""""
		local function get_env(thread)
			return thread.env
		end
		return get_env
	:
	host-func-type ((thread : tupleof-ascribed-names-reducer-thread-type)) -> ((env : host-environment))

let tupleof-ascribed-names-reducer-storage-defn = tuple-def-singleton(host-type, host-environment)

let tupleof-ascribed-names-reducer-result2-defn = tuple-def-singleton(host-type, tupleof-ascribed-names-reducer-thread-type)

let tupleof-ascribed-names-match-result-defn =
	# read as: (ok : host-bool, _ : host-if(ok, tupleof-ascribed-names-reducer-thread-type, host-lua-error))
	# or, more logically: (ok : host-bool, ...) where:
	# - ok == true:  `...` is tupleof-ascribed-names-reducer-thread-type
	# - ok == false: `...` is host-lua-error
	# technically this should have a third element in the ok == true case, containing host-syntax
	# but the syntax will always be nil, and the errors are annoying
	tuple-def-elem host-type
		tuple-def-elem host-type
			tuple-def-empty host-type
			lambda ()
				host-bool
		lambda ((ok : host-bool))
			host-if(ok, tupleof-ascribed-names-reducer-thread-type, host-lua-error)

# FIXME: tupleof_ascribed_names_inner can only produce tuple defs in star-0
let tupleof-ascribed-names-reducer = intrinsic "return base_env.tupleof_ascribed_names_inner" :
	reducer-type(host-unit, tupleof-ascribed-names-reducer-storage-defn, tupleof-ascribed-names-reducer-result2-defn, tupleof-ascribed-names-match-result-defn)

let tupleof-ascribed-names-match-accept-handler = intrinsic "return metalanguage.accept_handler" :
	reducible-handler-type(host-unit, tupleof-ascribed-names-reducer-result2-defn, tupleof-ascribed-names-match-result-defn)
let tupleof-ascribed-names-match-failure-handler = intrinsic "return metalanguage.failure_handler" :
	failure-handler-type(host-unit, tupleof-ascribed-names-match-result-defn)

let tuple-def-impl-type = operative-handler-type(host-unit)

let tuple-def-impl = lambda (syn : host-syntax, env : host-environment, ud : host-unit, goal : host-goal)
	let s = host-tuple-of(host-type, tupleof-ascribed-names-reducer-storage-defn)(env)

	let matcher-t = host-matcher(host-unit, tupleof-ascribed-names-match-result-defn)
	let matcher =
		host-matcher-reducible
			host-unit
			tupleof-ascribed-names-reducer-storage-defn
			tupleof-ascribed-names-reducer-result2-defn
			tupleof-ascribed-names-match-result-defn
			tupleof-ascribed-names-reducer
			s
			tupleof-ascribed-names-match-accept-handler

	let matchers =
		host-array-set
			host-array-new matcher-t
			1
			matcher

	let (ok, thread) =
		match-syntax
			host-unit
			tupleof-ascribed-names-match-result-defn
			matchers
			tupleof-ascribed-names-match-failure-handler
			syn
			host-nil

	let thread = error-filter(tupleof-ascribed-names-reducer-thread-type, host-lua-error, ok, thread)

	let (args) = tupleof-ascribed-names-reducer-thread-type-get-args(thread)
	let (env) = tupleof-ascribed-names-reducer-thread-type-get-env(thread)

	let (args) = goalify-inferrable(goal, args)

	tuple-of(host-type, operative-result-defn(goal))(args, env)

let (tuple-def-op-type, tuple-def-op) = new-operative(host-unit, host-nil, tuple-def-impl)

let my-tuple-def = tuple-def-op(x : host-number, y : host-number)
let my-tuple-type = tuple-type(type_(0), my-tuple-def)
my-tuple-type

let host-if-2-type = forall (result : host-type, c2 : host-type, a1 : host-type, subject : host-bool, consequent : host-if(subject, result, c2), alternate : host-if(subject, a1, result)) -> (r : result)

let host-if-2-wrap = intrinsic
	""""
		local typed = terms.typed_term
		local string_array = terms_gen.declare_array(terms_gen.builtin_string)
		return terms.value.closure(
			"#host-if-param",
			typed.tuple_elim(
				string_array(
					"#host-if-result",
					"#host-if-c2",
					"#host-if-a1",
					"#host-if-subject",
					"#host-if-consequent",
					"#host-if-alternate"
				),
				typed.bound_variable(1),
				6,
				typed.host_if(
					typed.bound_variable(5),
					typed.bound_variable(6),
					typed.bound_variable(7)
				)
			),
			terms.runtime_context()
		)
	:
	wrapped(host-if-2-type)
let host-if-2 = unwrap(host-if-2-type, host-if-2-wrap)

let host-true = intrinsic "return true" : host-bool
let host-false = intrinsic "return false" : host-bool

let host-if-test = lambda (
		b : host-bool,
		x : host-if(b, host-string, host-unit))
	let default = intrinsic "return 'default'" : host-if(b, host-string, host-string)
	let foo = host-if-2(host-string, host-unit, host-string, b, x, default)
	the host-string foo

host-if-test(host-true, "foobar")
host-if-test(host-false, host-nil)

let id = lambda_implicit (T : type_(10))
	lambda ((x : T))
		x

let tuple-of = lambda_implicit(T : type_(10))
	lambda (xs : T)
		xs

# TODO: test this when tuple-def-op can do more than just star-0
#let point = lambda_implicit (U : type_(10))
#	lambda ((T : U))
#		tuple-type(U, tuple-def-op(x : T, y : T))
#
#let mkpoint = lambda_implicit (U : type_(10), T : U)
#	lambda (x : T, y : T)
#		the point(T) tuple-of(x, y)
#
#let mul = intrinsic "return function(a, b) return a * b end" : host-arith-binop
#let add = intrinsic "return function(a, b) return a "+" b end" : host-arith-binop
#let sqmag = lambda ((r : tuple-type(tuple-def(x : host-number, y : host-number))))
#	let (x y) = r
#	add (mul x x) (mul y y)

#let test = sqmag(mkpoint(id(3), id(4)))

let _-_ = sub
12 - 3 - 5
