# types that need just a little convincing to exist

let prim-bool-wrap            = intrinsic "return terms.value.prim_bool_type"      : wrapped(prim-type)
let prim-string-wrap          = intrinsic "return terms.value.prim_string_type"    : wrapped(prim-type)
let prim-syntax-wrap          = intrinsic "return terms.prim_syntax_type"          : wrapped(prim-type)
let prim-environment-wrap     = intrinsic "return terms.prim_environment_type"     : wrapped(prim-type)
let prim-goal-wrap            = intrinsic "return terms.prim_goal_type"            : wrapped(prim-type)
let prim-inferrable-term-wrap = intrinsic "return terms.prim_inferrable_term_type" : wrapped(prim-type)
let prim-lua-error-wrap       = intrinsic "return terms.prim_lua_error_type"       : wrapped(prim-type)

let prim-bool            = unwrap(prim-type, prim-bool-wrap)
let prim-string          = unwrap(prim-type, prim-string-wrap)
let prim-syntax          = unwrap(prim-type, prim-syntax-wrap)
let prim-environment     = unwrap(prim-type, prim-environment-wrap)
let prim-goal            = unwrap(prim-type, prim-goal-wrap)
let prim-inferrable-term = unwrap(prim-type, prim-inferrable-term-wrap)
let prim-lua-error       = unwrap(prim-type, prim-lua-error-wrap)

# FIXME: type of universe
# we need to wrap this, and wrap takes a type in star-10
# so we have to settle for star-9
let universe = type_(9)

let prim-if-type = forall (subject : prim-bool) (consequent : prim-type) (alternate : prim-type) -> T : prim-type
let prim-if-wrap =
	intrinsic
		""""
			local typed = terms.typed_term
			local string_array = terms_gen.declare_array(terms_gen.builtin_string)
			return terms.value.closure(
				"#prim-if-param",
				typed.tuple_elim(
					string_array("#prim-if-subject", "#prim-if-consequent", "#prim-if-alternate"),
					typed.bound_variable(1),
					3,
					typed.prim_if(typed.bound_variable(2), typed.bound_variable(3), typed.bound_variable(4))
				),
				terms.runtime_context()
			)
		:
		wrapped(prim-if-type)
let prim-if = unwrap(prim-if-type, prim-if-wrap)




# setup for custom prim types
# the idea is that values of a type from here may be prims
# suitable for passing into prim functions
# so wrapping/unwrapping is unnecessary

let new-prim-type-inner =
	intrinsic
		""""
			local value_array = terms_gen.declare_array(terms.value)
			local function new_prim_type(name)
				local unique_id = { name = name }
				local basetype = terms.value.prim_user_defined_type(unique_id, value_array())
				return basetype
			end
			return new_prim_type
		:
		prim-func-type (name : prim-string) -> (T : wrapped(prim-type))
let new-prim-type =
	lambda ((name : prim-string))
		let (T) = new-prim-type-inner(name)
		unwrap(prim-type, T)

let new-prim-type-family-inner =
	intrinsic
		""""
			local typed_array = terms_gen.declare_array(terms.typed_term)
			local string_array = terms_gen.declare_array(terms_gen.builtin_string)
			local function new_prim_type_family(name, nparams, sig)
				local unique_id = { name = name }
				local params = typed_array()
				local param_names = string_array()
				for i = 1, nparams do
					params:append(terms.typed_term.bound_variable(i + 1))
					param_names:append("#type-family-A-" .. tostring(i))
				end
				local body = terms.typed_term.tuple_elim(
					param_names,
					terms.typed_term.bound_variable(1),
					nparams,
					terms.typed_term.prim_user_defined_type_cons(
						unique_id,
						params
					)
				)
				return terms.value.closure("#type-family-B", body, terms.runtime_context())
			end
			return new_prim_type_family
		:
		prim-func-type
			name      : prim-string
			nparams   : prim-number
			signature : wrapped(type_(1))
			->
			family    : wrapped(unwrap(type_(1), signature))
let new-prim-type-family =
	lambda 
		(name : prim-string) (nparams : prim-number) (signature : type_(1)) #TODO make nparams not exist by deriving it from the signature
		let (family) = new-prim-type-family-inner(name, nparams, wrap(type_(1), signature))
		unwrap(signature, family)




let prim-unit = new-prim-type("prim-unit")
let prim-nil = intrinsic "return nil" : prim-unit
let prim-literal = new-prim-type("literal")

let prim-array-type = new-prim-type-family "array" 1
	forall (T : prim-type) -> T : prim-type

let prim-matcher = new-prim-type-family "matcher" 2
	forall (userdata : prim-type) (result : prim-type) -> T : prim-type

let prim-reducer = new-prim-type-family "reducer" 3
	forall (storage : prim-type) (result : prim-type) (error : prim-type) -> T : prim-type




let prim-array-new =
	lambda ((T : prim-type))
		let inner =
			intrinsic
				""""
					local function array_new()
						return {}
					end
					return array_new
				:
				prim-func-type -> (arr : prim-array-type(T))
		let (arr) = inner()
		arr

let prim-array-set =
	lambda (T : prim-type, arr : prim-array-type(T), index : prim-number, elem : T)
		let inner =
			intrinsic
				""""
					local function array_set(array, index, elem)
						-- we have to clone because can't guarantee input array isn't reused
						-- Yet. growth mindset.
						cloned = {}
						for i, v in ipairs(array) do
							cloned[i] = v
						end
						cloned[index] = elem
						return cloned
					end
					return array_set
				:
				prim-func-type
					arr   : prim-array-type(T)
					index : prim-number
					elem  : T
					->
					arr   : prim-array-type(T)
		let (arr) = inner(arr, index, elem)
		arr

let prim-array-get = 
	lambda (T : prim-type, arr : prim-array-type(T), index : prim-number)
		let inner =
			intrinsic
				""""
					local function array_get(array, index)
						return array[index]
					end
					return array_get
				:
				prim-func-type
					arr   : prim-array-type(T)
					index : prim-number
					->
					elem  : T
		let (elem) = inner(arr, index)
		(the T elem)




# primitive and reducible matchers, the building blocks of syntax matching
# essentially a lot of busywork making trivial intrinsics and giving them proper types
# handler result types must be prim tuples
# notes: reducers (in lua) must return a bool to decide whether the match succeeded or failed
# thus adding this bool to the alicorn prim-reducer type is just noise
# handlers needn't, but may, for example to let the match caller know whether the syntax was accepted or not
# thus it's useful to represent this in the types in alicorn

let nil-handler-type =
	lambda (userdata : prim-type, result : prim-type)
		prim-func-type (ud : userdata) -> r : result
let prim-matcher-is-nil =
	lambda (userdata : prim-type, result : prim-type, accept-handler : nil-handler-type(userdata, result))
		let inner = intrinsic "return metalanguage.isnil" :
			prim-func-type (accept-handler : nil-handler-type(userdata, result)) -> (m : prim-matcher(userdata, result))
		let (m) = inner(accept-handler)
		m

let pair-handler-type =
	lambda (userdata : prim-type, result : prim-type)
		prim-func-type (ud : userdata) (a : prim-syntax) (b : prim-syntax) -> r : result
let prim-matcher-is-pair =
	lambda (userdata : prim-type, result : prim-type, accept-handler : pair-handler-type(userdata, result))
		let inner = intrinsic "return metalanguage.ispair" :
			prim-func-type (accept-handler : pair-handler-type(userdata, result)) -> (m : prim-matcher(userdata, result))
		let (m) = inner(accept-handler)
		m

let symbol-handler-type =
	lambda (userdata : prim-type, result : prim-type)
		prim-func-type (ud : userdata) (symbol : prim-string) -> r : result
let prim-matcher-is-symbol =
	lambda (userdata : prim-type, result : prim-type, accept-handler : symbol-handler-type(userdata, result))
		let inner = intrinsic "return metalanguage.issymbol" :
			prim-func-type (accept-handler : symbol-handler-type(userdata, result)) -> (m : prim-matcher(userdata, result))
		let (m) = inner(accept-handler)
		m

let value-handler-type =
	lambda (userdata : prim-type, result : prim-type)
		prim-func-type (ud : userdata) (val : prim-literal) -> r : result
let prim-matcher-is-value =
	lambda (userdata : prim-type, result : prim-type, accept-handler : value-handler-type(userdata, result))
		let inner = intrinsic "return metalanguage.isvalue" :
			prim-func-type (accept-handler : value-handler-type(userdata, result)) -> (m : prim-matcher(userdata, result))
		let (m) = inner(accept-handler)
		m

# the way result2 is put in the type here is actually completely wrong
# but it's all for intrinsics so hopefully it doesn't matter
let reducible-handler-type =
	lambda (userdata : prim-type, result2 : prim-type, result : prim-type)
		prim-func-type (ud : userdata) (r2 : result2) -> r : result
let prim-matcher-reducible =
	lambda (
		storage        : prim-type,
		result2        : prim-type,
		error          : prim-type,
		userdata       : prim-type,
		result         : prim-type,
		red            : prim-reducer(storage, result2, error),
		s              : storage,
		accept-handler : reducible-handler-type(userdata, result2, result))

		let inner =
			intrinsic
				""""
					local function reducible(red, s, accept_handler)
						return red(accept_handler, table.unpack(s))
					end
					return reducible
				:
				prim-func-type
					red            : prim-reducer(storage, result2, error)
					s              : wrapped(storage)
					accept-handler : reducible-handler-type(userdata, result2, result)
					->
					m              : prim-matcher(userdata, result)
		let (m) = inner(red, wrap(storage, s), accept-handler)
		m

let failure-handler-type =
	lambda (userdata : prim-type, result : prim-type)
		prim-func-type (ud : userdata) (exception : prim-lua-error) -> r : result

let match-syntax =
	lambda (
		userdata        : prim-type,
		result          : prim-type,
		matchers        : prim-array-type(prim-matcher(userdata, result)),
		failure-handler : failure-handler-type(userdata, result),
		syn             : prim-syntax,
		ud              : userdata)

		let inner =
			intrinsic
				""""
					local function match_syntax(matchers, failure_handler, syn, ud)
						return syn:match(matchers, failure_handler, ud)
					end
					return match_syntax
				:
				prim-func-type
					matchers        : prim-array-type(prim-matcher(userdata, result))
					failure-handler : failure-handler-type(userdata, result)
					syn             : prim-syntax
					ud              : wrapped(userdata)
					->
					r               : wrapped(result)
		let (r) = inner(matchers, failure-handler, syn, wrap(userdata, ud))
		unwrap(result, r)




# explicit tuple types (horrible to use)

let tuple-def-type-inner = intrinsic "return terms.value.tuple_defn_type" :
	prim-func-type (U : wrapped(universe)) -> (T : wrapped(prim-type))
let tuple-def-type =
	lambda ((U : universe))
		let (T) = tuple-def-type-inner(wrap(universe, U))
		unwrap(prim-type, T)
let tuple-type =
	lambda (U : universe, decls : tuple-def-type(U))
		let inner = intrinsic "return terms.value.tuple_type" :
			prim-func-type (decls : wrapped(tuple-def-type(U))) -> (T : wrapped(prim-type))
		let (T) = inner(wrap(tuple-def-type(U), decls))
		unwrap(prim-type, T)
let prim-tuple-type =
	lambda (U : universe, decls : tuple-def-type(U))
		let inner = intrinsic "return terms.value.prim_tuple_type" :
			prim-func-type (decls : wrapped(tuple-def-type(U))) -> (T : wrapped(prim-type))
		let (T) = inner(wrap(tuple-def-type(U), decls))
		unwrap(prim-type, T)
let tuple-def-empty =
	lambda ((U : universe))
		let T = tuple-def-type(U)
		let empty =
			intrinsic
				""""
					local value_array = terms_gen.declare_array(terms.value)
					return terms.value.enum_value("empty", terms.value.tuple_value(value_array()))
				:
				wrapped(T)
		unwrap(T, empty)
let tuple-def-elem =
	lambda (
		U    : universe,
		defn : tuple-def-type(U),
		elem : (forall rest : tuple-type(U, defn) -> next : U))

		let inner =
			intrinsic
				""""
					local value_array = terms_gen.declare_array(terms.value)
					local function tuple_def_elem(defn, elem)
						return terms.value.enum_value("cons", terms.value.tuple_value(value_array(defn, elem)))
					end
					return tuple_def_elem
				:
				prim-func-type
					defn_ : wrapped(tuple-def-type(U)) # aaaa shadowing
					elem  : (wrapped (forall rest : tuple-type(U, defn) -> next : U))
					->
					T     : wrapped(tuple-def-type(U))
		let (T) = inner(wrap(tuple-def-type(U), defn), (wrap (forall rest : tuple-type(U, defn) -> next : U) elem))
		unwrap(tuple-def-type(U), T)
# lazy copypaste
#let prim-tuple-def-empty =
	lambda ((U : universe))
		let T = tuple-def-type(U)
		let empty =
			intrinsic
				""""
					local any_array = terms_gen.declare_array(terms_gen.any_lua_type)
					return terms.value.enum_value("empty", terms.value.prim_tuple_value(any_array()))
				:
				wrapped(T)
		unwrap(T, empty)
#let prim-tuple-def-elem =
	lambda (
		U    : universe,
		defn : tuple-def-type(U),
		elem : (forall rest : prim-tuple-type(U, defn) -> next : U))

		let inner =
			intrinsic
				""""
					local any_array = terms_gen.declare_array(terms_gen.any_lua_type)
					local function tuple_def_elem(defn, elem)
						return terms.value.enum_value("cons", terms.value.prim_tuple_value(any_array(defn, elem)))
					end
					return tuple_def_elem
				:
				prim-func-type
					defn_ : wrapped(tuple-def-type(U)) # aaaa shadowing
					elem  : (wrapped (forall rest : prim-tuple-type(U, defn) -> next : U))
					->
					T     : wrapped(tuple-def-type(U))
		let (T) = inner(wrap(tuple-def-type(U), defn), (wrap (forall rest : prim-tuple-type(U, defn) -> next : U) elem))
		unwrap(tuple-def-type(U), T)




# FIXME: this should be in terms.lua probably
let prim-expression-args = new-prim-type("expression-args")
let expression-args-new = intrinsic "return alicorn_expressions.ExpressionArgs.new" :
	prim-func-type (goal : prim-goal) (env : prim-environment) -> (args : prim-expression-args)
# lol look how horrible tuple types are
# FIXME: currently assuming block returns always inferrable
# this is true now, but a task is out to fix this in lua
# when that happens this should be fixed here too
let block-reducer-result2-type =
	prim-tuple-type prim-type
		tuple-def-elem prim-type
			tuple-def-elem prim-type
				tuple-def-empty prim-type
				lambda (())
					prim-inferrable-term
			lambda ((_ : prim-inferrable-term))
				prim-environment
let block-match-result-type =
	prim-tuple-type prim-type
		tuple-def-elem prim-type
			tuple-def-elem prim-type
				tuple-def-elem prim-type
					tuple-def-empty prim-type
					lambda (())
						prim-bool
				lambda ((success : prim-bool))
					prim-if(success, prim-inferrable-term, prim-lua-error)
			lambda (success : prim-bool, _ : prim-if(success, prim-inferrable-term, prim-lua-error))
				# hacky way to do variable-length prim tuples
				prim-if(success, prim-environment, prim-unit)
let block-reducer = intrinsic "return alicorn_expressions.block" :
	prim-reducer(prim-expression-args, block-reducer-result2-type, prim-lua-error)

# let's make the `do` operative!

let do-impl =
	lambda (userdata : prim-type, syn : prim-syntax, env : prim-environment, ud : userdata, goal : prim-goal)
		let (args) = expression-args-new(goal, env)
		# these lua functions are used in a very polymorphic way
		# for a few simplicity reasons, they are defined here instead of generically
		let accept-handler = intrinsic "return metalanguage.accept_handler" :
			prim-func-type (ud : userdata) (r2 : block-reducer-result2-type) -> r : block-match-result-type
		let failure-handler = intrinsic "return metalanguage.failure_handler" :
			prim-func-type (ud : userdata) (exception : prim-lua-error) -> r : block-match-result-type
		let matcher = prim-matcher-reducible(prim-expression-args, block-reducer-result2-type, prim-lua-error, userdata, block-match-result-type, block-reducer, args, accept-handler)
		let matcher-t = prim-matcher(userdata, block-match-result-type)
		let matchers = prim-array-set(matcher-t, prim-array-new(matcher-t), 1, matcher)
		#let res = match-syntax(userdata, block-reducer-result-type, matchers, ..., syn, ud)
