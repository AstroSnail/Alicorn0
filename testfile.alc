#let x = 621
#let y = 926
#let prim-add = +

let prim-arith-binop = (prim-func-type (a : prim-number) (b : prim-number) -> (c : prim-number))
let prim-sub = (intrinsic "return function(a, b) return a - b end" : prim-arith-binop)

#let prim-sub = (intrinsic "return function(a, b) return a - b end" : (prim-func-type (a : prim-number) (b : prim-number) -> (c : prim-number)))

#let foo = (record (bar = 5) (baz = 6))
#let subbed = prim-sub foo.bar y

# this should error becaused prim-type is not a prim-type and therefore can't be an arg to a prim-func-type
# but it doesn't.
let array-type =
	intrinsic
		""""
			-- terms and terms_gen implicitly in env
			local value = terms.value
			assert(value and value.prim)
			local value_array = terms_gen.declare_array(value)
			local id = value.prim_user_defined_type({name = "array"}, value_array())
			local function mktype(elem)
				print("mktype id", id)
				print("mktype elem", elem)
				return value.prim_boxed_type(id, value_array(elem))
			end
			return mktype
		:
		prim-func-type (T : (boxed prim-type)) -> (array : (boxed prim-type))

#let (val) =
#	+ x 5

#let (val) =
#	+ val y

#prim-sub foo.bar val

let (val) = (prim-sub 5 1)
prim-sub val 3

let number-array = (array-type (box prim-type prim-number))

let sub = 
	lambda (x : prim-number, y : prim-number)
		let (val) = (prim-sub x y)
		val

sub 5 (sub 3 2)

number-array
